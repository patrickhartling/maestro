// qgl.sip generated by MetaSIP on Wed Oct 11 03:37:28 2006
//
// This file is part of the QtOpenGL Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qgl.h>
%End


typedef int GLint;
typedef unsigned GLuint;
typedef unsigned GLenum;

namespace QGL
{
%TypeHeaderCode
#include <qgl.h>
%End

    enum FormatOption
    {
        DoubleBuffer,
        DepthBuffer,
        Rgba,
        AlphaChannel,
        AccumBuffer,
        StencilBuffer,
        StereoBuffers,
        DirectRendering,
        HasOverlay,
        SampleBuffers,
        SingleBuffer,
        NoDepthBuffer,
        ColorIndex,
        NoAlphaChannel,
        NoAccumBuffer,
        NoStencilBuffer,
        NoStereoBuffers,
        IndirectRendering,
        NoOverlay,
        NoSampleBuffers,
    };

    typedef QFlags<QGL::FormatOption> FormatOptions;
};

QFlags<QGL::FormatOption> operator|(QGL::FormatOption f1, QFlags<QGL::FormatOption> f2);
QFlags<QGL::FormatOption> operator|(QGL::FormatOption f1, QGL::FormatOption f2);

class QGLFormat
{

%TypeHeaderCode
#include <qgl.h>
%End

public:
%If (Qt_4_2_0 -)

    enum OpenGLVersionFlag
    {
        OpenGL_Version_None,
        OpenGL_Version_1_1,
        OpenGL_Version_1_2,
        OpenGL_Version_1_3,
        OpenGL_Version_1_4,
        OpenGL_Version_1_5,
        OpenGL_Version_2_0,
        OpenGL_Version_2_1,
        OpenGL_ES_Common_Version_1_0,
        OpenGL_ES_CommonLite_Version_1_0,
        OpenGL_ES_Common_Version_1_1,
        OpenGL_ES_CommonLite_Version_1_1,
        OpenGL_ES_Version_2_0,
    };

%End
%If (Qt_4_2_0 -)
    typedef QFlags<QGLFormat::OpenGLVersionFlag> OpenGLVersionFlags;
%End
    QGLFormat();
    QGLFormat(QGL::FormatOptions options, int plane = 0);
    QGLFormat(const QGLFormat &other);
    ~QGLFormat();
    void setDepthBufferSize(int size);
    int depthBufferSize() const;
    void setAccumBufferSize(int size);
    int accumBufferSize() const;
    void setAlphaBufferSize(int size);
    int alphaBufferSize() const;
    void setStencilBufferSize(int size);
    int stencilBufferSize() const;
    void setSampleBuffers(bool enable);
    void setSamples(int numSamples);
    int samples() const;
    void setDoubleBuffer(bool enable);
    void setDepth(bool enable);
    void setRgba(bool enable);
    void setAlpha(bool enable);
    void setAccum(bool enable);
    void setStencil(bool enable);
    void setStereo(bool enable);
    void setDirectRendering(bool enable);
    void setOverlay(bool enable);
    int plane() const;
    void setPlane(int plane);
    void setOption(QGL::FormatOptions opt);
    bool testOption(QGL::FormatOptions opt) const;
    static QGLFormat defaultFormat();
    static void setDefaultFormat(const QGLFormat &f);
    static QGLFormat defaultOverlayFormat();
    static void setDefaultOverlayFormat(const QGLFormat &f);
    static bool hasOpenGL();
    static bool hasOpenGLOverlays();
    bool doubleBuffer() const;
    bool depth() const;
    bool rgba() const;
    bool alpha() const;
    bool accum() const;
    bool stencil() const;
    bool stereo() const;
    bool directRendering() const;
    bool hasOverlay() const;
    bool sampleBuffers() const;
%If (Qt_4_2_0 -)
    void setRedBufferSize(int size);
%End
%If (Qt_4_2_0 -)
    int redBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setGreenBufferSize(int size);
%End
%If (Qt_4_2_0 -)
    int greenBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setBlueBufferSize(int size);
%End
%If (Qt_4_2_0 -)
    int blueBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setSwapInterval(int interval);
%End
%If (Qt_4_2_0 -)
    int swapInterval() const;
%End
%If (Qt_4_2_0 -)
    static QFlags<QGLFormat::OpenGLVersionFlag> openGLVersionFlags();
%End
};

bool operator==(const QGLFormat &, const QGLFormat &);
bool operator!=(const QGLFormat &, const QGLFormat &);

class QGLContext
{

%TypeHeaderCode
#include <qgl.h>
%End

public:
    QGLContext(const QGLFormat &format, QPaintDevice *device);
    virtual ~QGLContext();
    virtual bool create(const QGLContext *shareContext = 0);
    bool isValid() const;
    bool isSharing() const;
    void reset();
    QGLFormat format() const;
    QGLFormat requestedFormat() const;
    void setFormat(const QGLFormat &format);
    virtual void makeCurrent();
    virtual void doneCurrent();
    virtual void swapBuffers() const;
    GLuint bindTexture(const QImage &image, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA8);
    GLuint bindTexture(const QPixmap &pixmap, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA8);
    GLuint bindTexture(const QString &fileName);
    void deleteTexture(GLuint tx_id);
    static void setTextureCacheLimit(int size);
    static int textureCacheLimit();
    void *getProcAddress(const QString &proc) const;
    QPaintDevice *device() const;
    QColor overlayTransparentColor() const;
    static const QGLContext *currentContext();

protected:
    virtual bool chooseContext(const QGLContext *shareContext = 0);
%If (WS_X11)
    virtual void *chooseVisual();
%End
    bool deviceIsPixmap() const;
    bool windowCreated() const;
    void setWindowCreated(bool on);
    bool initialized() const;
    void setInitialized(bool on);
    void generateFontDisplayLists(const QFont &fnt, int listBase);

private:
    QGLContext(const QGLContext &);
};

class QGLWidget : QWidget
{

%TypeHeaderCode
#include <qgl.h>
%End

%ConvertToSubClassCode
    sipClass = (sipCpp->inherits(sipName_QGLWidget) ? sipClass_QGLWidget : 0);
%End

public:
%If (- Qt_4_2_0)
    QGLWidget(QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags f = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags f = 0);
%End
%If (- Qt_4_2_0)
    QGLWidget(QGLContext *context /Transfer/, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags f = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(QGLContext *context /Transfer/, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags f = 0);
%End
%If (- Qt_4_2_0)
    QGLWidget(const QGLFormat &format, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags f = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(const QGLFormat &format, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags f = 0);
%End
    virtual ~QGLWidget();
    void qglColor(const QColor &c) const;
    void qglClearColor(const QColor &c) const;
    bool isValid() const;
    bool isSharing() const;
    void makeCurrent();
    void doneCurrent();
    bool doubleBuffer() const;
    void swapBuffers();
    QGLFormat format() const;
    void setFormat(const QGLFormat &format);
    const QGLContext *context() const;
    void setContext(QGLContext *context, const QGLContext *shareContext = 0, bool deleteOldContext = true);
    QPixmap renderPixmap(int w = 0, int h = 0, bool useContext = false);
    QImage grabFrameBuffer(bool withAlpha = false);
    void makeOverlayCurrent();
    const QGLContext *overlayContext() const;
    static QImage convertToGLFormat(const QImage &img);
    void setMouseTracking(bool enable);
    const QGLColormap &colormap() const;
    void setColormap(const QGLColormap &map);
    void renderText(int x, int y, const QString &str, const QFont &fnt = QFont(), int listBase = 2000);
    void renderText(double x, double y, double z, const QString &str, const QFont &fnt = QFont(), int listBase = 2000);
    virtual QPaintEngine *paintEngine() const;
    GLuint bindTexture(const QImage &image, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA8);
    GLuint bindTexture(const QPixmap &pixmap, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA8);
    GLuint bindTexture(const QString &fileName);
    void deleteTexture(GLuint tx_id);

public slots:
    virtual void updateGL();
    virtual void updateOverlayGL();

protected:
    virtual bool event(QEvent *);
    virtual void initializeGL();
    virtual void resizeGL(int w, int h);
    virtual void paintGL();
    virtual void initializeOverlayGL();
    virtual void resizeOverlayGL(int w, int h);
    virtual void paintOverlayGL();
    void setAutoBufferSwap(bool on);
    bool autoBufferSwap() const;
    virtual void paintEvent(QPaintEvent *);
    virtual void resizeEvent(QResizeEvent *);
    virtual void glInit();
    virtual void glDraw();
    int fontDisplayListBase(const QFont &fnt, int listBase = 2000);

private:
    QGLWidget(const QGLWidget &);
};

%If (Qt_4_2_0 -)
QFlags<QGLFormat::OpenGLVersionFlag> operator|(QGLFormat::OpenGLVersionFlag f1, QFlags<QGLFormat::OpenGLVersionFlag> f2);
%End
%If (Qt_4_2_0 -)
QFlags<QGLFormat::OpenGLVersionFlag> operator|(QGLFormat::OpenGLVersionFlag f1, QGLFormat::OpenGLVersionFlag f2);
%End
