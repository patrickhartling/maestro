// qobjectdefs.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


struct QMetaObject
{

%TypeHeaderCode
#include <qobjectdefs.h>
%End

    const char *className() const;
    const QMetaObject *superClass() const;
    int methodOffset() const;
    int enumeratorOffset() const;
    int propertyOffset() const;
    int classInfoOffset() const;
    int methodCount() const;
    int enumeratorCount() const;
    int propertyCount() const;
    int classInfoCount() const;
    int indexOfMethod(const char *method) const;
    int indexOfSignal(const char *signal) const;
    int indexOfSlot(const char *slot) const;
    int indexOfEnumerator(const char *name) const;
    int indexOfProperty(const char *name) const;
    int indexOfClassInfo(const char *name) const;
    QMetaMethod method(int index) const;
    QMetaEnum enumerator(int index) const;
    QMetaProperty property(int index) const;
    QMetaClassInfo classInfo(int index) const;
    static bool checkConnectArgs(const char *signal, const char *method);
    static QByteArray normalizedSignature(const char *method);
    static void connectSlotsByName(QObject *o /GetWrapper/);
%MethodCode
        // Get the class attributes.
        PyObject *dir = PyObject_Dir((PyObject *)a0Wrapper->ob_type);
        
        // Objectify the attribute name.
        static PyObject *sigstr = 0;
        
        if (!sigstr)
            sigstr = PyString_FromString("_signature");
        
        if (dir && sigstr)
        {
            PyObject *slot_obj = 0;
        
            for (int li = 0; li < PyList_GET_SIZE(dir); ++li)
            {
                PyObject *name_obj = PyList_GET_ITEM(dir, li);
                const char *name = PyString_AsString(name_obj);
        
                if (!name)
                    continue;
        
                // Get the slot object.
                Py_XDECREF(slot_obj);
                slot_obj = PyObject_GetAttr(a0Wrapper, name_obj);
        
                if (!slot_obj)
                    continue;
        
                // Ignore it if it is not a callable.
                if (!PyCallable_Check(slot_obj))
                    continue;
        
                // Use the signature attribute instead of the name if there is one.
                PyObject *sigattr = PyObject_GetAttr(slot_obj, sigstr);
                QByteArray slot_nm, args;
        
                if (sigattr)
                {
                    // It's safe (and very convenient) to do this because we have a
                    // reference to the containing dictionary.
                    Py_DECREF(sigattr);
        
                    const char *sn = PyString_AsString(sigattr);
        
                    if (!sn)
                        continue;
        
                    // If there is an opening parenthesis then assume we are using the
                    // long version and take the name from the signature.  Otherwise
                    // assume the signature just contains the arguments and take the
                    // name from the slot.
                    const char *astart = strchr(sn, '(');
        
                    if (astart)
                    {
                        slot_nm = QByteArray::fromRawData(sn, astart - sn);
        
                        ++astart;
        
                        const char *aend = strrchr(astart, ')');
        
                        if (!aend || aend < astart)
                            continue;
        
                        args = QByteArray::fromRawData(astart, aend - astart);
                    }
                    else
                    {
                        slot_nm = name;
                        args = sn;
                    }
                }
                else
                {
                    PyErr_Clear();
        
                    slot_nm = name;
                }
        
                // Ignore if it's not an autoconnect slot.
                if (!slot_nm.startsWith("on_"))
                    continue;
        
                // Extract the names of the emitting object and the signal.
                int i;
        
                i = slot_nm.lastIndexOf('_');
        
                if (i - 3 < 1 || i + 1 >= slot_nm.size())
                    continue;
        
                QByteArray ename = slot_nm.mid(3, i - 3);
                QByteArray sname = slot_nm.mid(i + 1);
        
                // Find the emitting object and get its meta-object.
        #if defined(QT_NO_MEMBER_TEMPLATES)
                QObject *eobj = qFindChild<QObject *>(a0, ename);
        #else
                QObject *eobj = a0->findChild<QObject *>(ename);
        #endif
        
                if (!eobj)
                    continue;
        
                const QMetaObject *mo = eobj->metaObject();
        
                // Got through the methods looking for a matching signal.
                PyObject *epyobj = 0;
        
                for (int m = 0; m < mo->methodCount(); ++m)
                {
                    QMetaMethod mm = mo->method(m);
        
                    if (mm.methodType() != QMetaMethod::Signal)
                        continue;
        
                    // Get the signal name without arguments.
                    QByteArray sig(mm.signature());
                    int argstart = sig.indexOf('(');
                    QByteArray signoargs = sig.left(argstart);
        
                    if (signoargs != sname)
                        continue;
        
                    ++argstart;
        
                    // If we have slot arguments then they must match as well.
                    if (!args.isNull() && sig.mid(argstart, sig.lastIndexOf(')') - argstart) != args)
                        continue;
        
                    // Add the type character.
                    sig.prepend('2');
        
                    // Get the wrapper now we know it is needed.
                    if (!epyobj)
                    {
                        epyobj = sipConvertFromInstance(eobj, sipClass_QObject, 0);
        
                        if (!epyobj)
                            break;
                    }
        
                    // Connect the signal.
                    sipConnectRx(epyobj, sig, slot_obj, 0, 0);
                }
        
                Py_XDECREF(epyobj);
            }
        
            Py_XDECREF(slot_obj);
        }
        
        Py_XDECREF(dir);
%End
};
