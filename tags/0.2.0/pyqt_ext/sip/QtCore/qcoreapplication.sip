// qcoreapplication.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qcoreapplication.h>
%End


%If (WS_WIN)
// Windows specific definitions.
// These would normally be in qwindowdefs.h but are needed by
// qcoreapplication.h.
typedef struct HWND__ *HWND;
typedef unsigned UINT;
typedef long LONG;
typedef unsigned long DWORD;
typedef UINT WPARAM;
typedef LONG LPARAM;

struct POINT
{
%TypeHeaderCode
#include <wtypes.h>
%End

    LONG x;
    LONG y;
};

struct MSG
{
%TypeHeaderCode
#include <wtypes.h>
%End

    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
};
%End

class QCoreApplication : QObject /DelayDtor/
{

%TypeHeaderCode
#include <qcoreapplication.h>
%End

%TypeCode
// Convert a Python argv list to a conventional C argc count and argv array.
static char **qtcore_ArgvToC(PyObject *argvlist, int &argc)
{
    char **argv;

    argc = PyList_GET_SIZE(argvlist);

    // Allocate space for two copies of the argument pointers, plus the
    // terminating NULL.
    if ((argv = (char **)sipMalloc(2 * (argc + 1) * sizeof (char *))) == NULL)
        return NULL;

    // Convert the list.
    for (int a = 0; a < argc; ++a)
    {
        char *arg;

        // Get the argument and allocate memory for it.
        if ((arg = PyString_AsString(PyList_GET_ITEM(argvlist, a))) == NULL ||
            (argv[a] = (char *)sipMalloc(strlen(arg) + 1)) == NULL)
            return NULL;

        // Copy the argument and save a pointer to it.
        strcpy(argv[a], arg);
        argv[a + argc + 1] = argv[a];
    }

    argv[argc + argc + 1] = argv[argc] = NULL;

    return argv;
}


// Remove arguments from the Python argv list that have been removed from the
// C argv array.
static void qtcore_UpdatePyArgv(PyObject *argvlist, int argc, char **argv)
{
    for (int a = 0, na = 0; a < argc; ++a)
    {
        // See if it was removed.
        if (argv[na] == argv[a + argc + 1])
            ++na;
        else
            PyList_SetSlice(argvlist, na, na + 1, NULL);
    }
}
%End

public:
    QCoreApplication(SIP_PYLIST argv) /PostHook=__pyQtQAppHook/ [(int &argc, char **argv)];
%MethodCode
        // The Python interface is a list of argument strings that is modified.
        
        int argc;
        char **argv;
        
        // Convert the list.
        if ((argv = qtcore_ArgvToC(a0, argc)) == NULL)
            sipIsErr = 1;
        else
        {
            // Create it now the arguments are right.
            static int nargc = argc;
        
            sipCpp = new sipQCoreApplication(nargc, argv);
        
            // Now modify the original list.
            qtcore_UpdatePyArgv(a0, argc, argv);
        }
%End

    virtual ~QCoreApplication();
    static int argc();
    static SIP_PYLIST argv();
%MethodCode
        // The Python interface returns a list of strings.
        
        int argc = QCoreApplication::argc();
        
        if ((sipRes = PyList_New(argc)) == NULL)
            sipIsErr = 1;
        else
        {
            char **argv = QCoreApplication::argv();
        
            for (int a = 0; a < argc; ++a)
                if (PyList_SET_ITEM(sipRes, a, PyString_FromString(argv[a])) < 0)
                {
                    Py_DECREF(sipRes);
                    sipIsErr = 1;
                    break;
                }
        }
%End

    static void setOrganizationDomain(const QString &orgDomain);
    static QString organizationDomain();
    static void setOrganizationName(const QString &orgName);
    static QString organizationName();
    static void setApplicationName(const QString &application);
    static QString applicationName();
    static QStringList arguments();
    static QCoreApplication *instance();
    static int exec() /PostHook=__pyQtPostEventLoopHook__, PreHook=__pyQtPreEventLoopHook__, PyName=exec_, ReleaseGIL/;
    static void processEvents(QFlags<QEventLoop::ProcessEventsFlag> flags = QEventLoop::AllEvents) /ReleaseGIL/;
    static void processEvents(QFlags<QEventLoop::ProcessEventsFlag> flags, int maxtime) /ReleaseGIL/;
    static void exit(int retcode = 0);
    static bool sendEvent(QObject *receiver, QEvent *event) /ReleaseGIL/;
    static void postEvent(QObject *receiver, QEvent *event /Transfer/);
    static void sendPostedEvents(QObject *receiver, int event_type) /ReleaseGIL/;
    static void sendPostedEvents() /ReleaseGIL/;
    static void removePostedEvents(QObject *receiver);
    static bool hasPendingEvents();
    virtual bool notify(QObject *, QEvent *) /ReleaseGIL/;
    static bool startingUp();
    static bool closingDown();
    static QString applicationDirPath();
    static QString applicationFilePath();
    static void setLibraryPaths(const QStringList &);
    static QStringList libraryPaths();
    static void addLibraryPath(const QString &);
    static void removeLibraryPath(const QString &);
    static void installTranslator(QTranslator *);
    static void removeTranslator(QTranslator *);

    enum Encoding
    {
        DefaultCodec,
        UnicodeUTF8,
    };

    static QString translate(const char *context, const char *key, const char *comment = 0, QCoreApplication::Encoding encoding = QCoreApplication::DefaultCodec);
    static void flush() /ReleaseGIL/;
%If (WS_WIN)
    virtual bool winEventFilter(MSG *message, long *result);
%End

public slots:
    static void quit();

signals:
    void aboutToQuit();
    void unixSignal(int);

protected:
    virtual bool event(QEvent *);
};

void qAddPostRoutine(SIP_PYCALLABLE);
%MethodCode
    // Add it to the list of post routines if it already exists.
    if (qtcore_PostRoutines != NULL)
    {
        // See if there is an empty slot.
        bool app = true;
    
        for (int i = 0; i < PyList_GET_SIZE(qtcore_PostRoutines); ++i)
            if (PyList_GET_ITEM(qtcore_PostRoutines, i) == Py_None)
            {
                Py_DECREF(Py_None);
                Py_INCREF(a0);
                PyList_SET_ITEM(qtcore_PostRoutines, i, a0);
    
                app = false;
    
                break;
            }
    
        if (app && PyList_Append(qtcore_PostRoutines, a0) < 0)
            sipIsErr = 1;
    }
    else if ((qtcore_PostRoutines = PyList_New(1)) != NULL)
    {
        Py_INCREF(a0);
        PyList_SET_ITEM(qtcore_PostRoutines, 0, a0);
    
        qAddPostRoutine(qtcore_CallPostRoutines);
    }
    else
        sipIsErr = 1;
%End

void qRemovePostRoutine(SIP_PYCALLABLE);
%MethodCode
    // Remove it from the list of post routines if it exists.
    if (qtcore_PostRoutines != NULL)
        for (int i = 0; i < PyList_GET_SIZE(qtcore_PostRoutines); ++i)
            if (PyList_GET_ITEM(qtcore_PostRoutines, i) == a0)
            {
                Py_DECREF(a0);
                Py_INCREF(Py_None);
                PyList_SET_ITEM(qtcore_PostRoutines, i, Py_None);
    
                break;
            }
%End

// Module code needed by qAddPostRoutine() and qRemovePostRoutine().
%ModuleCode
// The list of Python post routines.
static PyObject *qtcore_PostRoutines = NULL;


// Call all of the registered Python post routines.
static void qtcore_CallPostRoutines()
{
    for (int i = 0; i < PyList_GET_SIZE(qtcore_PostRoutines); ++i)
    {
        PyObject *pr = PyList_GET_ITEM(qtcore_PostRoutines, i);

        if (pr != Py_None)
        {
            PyObject *res = PyObject_CallObject(pr, NULL);

            Py_XDECREF(res);
        }
    }
}
%End

%ModuleCode
// Handle any delayed dtors calls.
extern "C" {static void sipDelayedDtors(const sipDelayedDtor *ddlist);}

static void sipDelayedDtors(const sipDelayedDtor *ddlist)
{
    // QCoreApplication is the only DelayDtor class and there should only be
    // one instance.
    while (ddlist)
    {
        if (ddlist->dd_isderived)
            delete reinterpret_cast<sipQCoreApplication *>(ddlist->dd_ptr);
        else
            delete reinterpret_cast<QCoreApplication *>(ddlist->dd_ptr);

        ddlist = ddlist->dd_next;
    }
}
%End
