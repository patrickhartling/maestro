// qkeysequence.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qkeysequence.h>
%End


class QKeySequence
{

%TypeHeaderCode
#include <qkeysequence.h>
%End

%ConvertToTypeCode
// Allow a QString or an integer whenever a QKeySequence is expected.

if (sipIsErr == NULL)
{
    if (sipCanConvertToInstance(sipPy, sipClass_QKeySequence, SIP_NO_CONVERTORS))
        return 1;

    if (sipCanConvertToInstance(sipPy, sipClass_QString, 0))
        return 1;

    PyErr_Clear();

    PyInt_AsLong(sipPy);

    return !PyErr_Occurred();
}

if (sipCanConvertToInstance(sipPy, sipClass_QKeySequence, SIP_NO_CONVERTORS))
{
    *sipCppPtr = reinterpret_cast<QKeySequence *>(sipConvertToInstance(sipPy, sipClass_QKeySequence, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

    return 0;
}

if (sipCanConvertToInstance(sipPy, sipClass_QString, 0))
{
    int state;
    QString *qs = reinterpret_cast<QString *>(sipConvertToInstance(sipPy, sipClass_QString, 0, 0, &state, sipIsErr));

    if (*sipIsErr)
    {
        sipReleaseInstance(qs, sipClass_QString, state);
        return 0;
    }

    *sipCppPtr = new QKeySequence(*qs);

    sipReleaseInstance(qs, sipClass_QString, state);

    return sipGetState(sipTransferObj);
}

int key = PyInt_AsLong(sipPy);

*sipCppPtr = new QKeySequence(key);

return sipGetState(sipTransferObj);
%End

public:
    QKeySequence();
    QKeySequence(const QString &key);
    QKeySequence(int k1, int k2 = 0, int k3 = 0, int k4 = 0);
    QKeySequence(const QVariant &) /NoDerived/;
%MethodCode
        sipCpp = new QKeySequence(qVariantValue<QKeySequence>(*a0));
%End

    QKeySequence(const QKeySequence &ks);
    ~QKeySequence();
    uint count() const;
    bool isEmpty() const;

    enum SequenceMatch
    {
        NoMatch,
        PartialMatch,
        ExactMatch,
    };

    QKeySequence::SequenceMatch matches(const QKeySequence &seq) const;
    static QKeySequence mnemonic(const QString &text);
    operator QString() const;
    operator QVariant() const;
    operator int() const;
    int operator[](uint i) const;
    bool operator==(const QKeySequence &other) const;
    bool operator!=(const QKeySequence &other) const;
    bool operator<(const QKeySequence &ks) const;
    bool operator>(const QKeySequence &other) const;
    bool operator<=(const QKeySequence &other) const;
    bool operator>=(const QKeySequence &other) const;
    bool isDetached() const;

    enum SequenceFormat
    {
        NativeText,
        PortableText,
    };

    QString toString(QKeySequence::SequenceFormat format = QKeySequence::PortableText) const;
    static QKeySequence fromString(const QString &str, QKeySequence::SequenceFormat format = QKeySequence::PortableText);
};

QDataStream &operator<<(QDataStream &in, const QKeySequence &ks /Constrained/);
QDataStream &operator>>(QDataStream &out, QKeySequence &ks /Constrained/);
