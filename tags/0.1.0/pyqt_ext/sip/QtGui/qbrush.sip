// qbrush.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qbrush.h>
%End


class QBrush
{

%TypeHeaderCode
#include <qbrush.h>
%End

%ConvertToTypeCode
// SIP doesn't support automatic type convertors so we explicitly allow a
// QColor to be used whenever a QBrush is expected.  Note that SIP must process
// QColor before QBrush so that the former's QVariant cast operator is applied
// before the latter's.

if (sipIsErr == NULL)
    return (sipCanConvertToInstance(sipPy, sipClass_QBrush, SIP_NO_CONVERTORS) ||
            sipCanConvertToInstance(sipPy, sipClass_QColor, 0));

if (sipCanConvertToInstance(sipPy, sipClass_QBrush, SIP_NO_CONVERTORS))
{
    *sipCppPtr = reinterpret_cast<QBrush *>(sipConvertToInstance(sipPy, sipClass_QBrush, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

    return 0;
}

int state;
QColor *c = reinterpret_cast<QColor *>(sipConvertToInstance(sipPy, sipClass_QColor, 0, 0, &state, sipIsErr));

if (*sipIsErr)
{
    sipReleaseInstance(c, sipClass_QColor, state);
    return 0;
}

*sipCppPtr = new QBrush(*c);

sipReleaseInstance(c, sipClass_QColor, state);

return sipGetState(sipTransferObj);
%End

public:
    QBrush();
    QBrush(Qt::BrushStyle bs);
    QBrush(const QColor &color, Qt::BrushStyle bs = Qt::SolidPattern);
    QBrush(Qt::GlobalColor color, Qt::BrushStyle bs = Qt::SolidPattern);
    QBrush(const QColor &color, const QPixmap &pixmap);
    QBrush(Qt::GlobalColor color, const QPixmap &pixmap);
    QBrush(const QPixmap &pixmap);
    QBrush(const QGradient &gradient);
    QBrush(const QVariant &) /NoDerived/;
%MethodCode
        sipCpp = new QBrush(qVariantValue<QBrush>(*a0));
%End

    QBrush(const QBrush &brush);
    ~QBrush();
    operator QVariant() const;
    void setStyle(Qt::BrushStyle);
    QPixmap texture() const;
    void setTexture(const QPixmap &pixmap);
    void setColor(const QColor &color);
    const QGradient *gradient() const;
    bool isOpaque() const;
    bool operator==(const QBrush &b) const;
    bool operator!=(const QBrush &b) const;
    void setColor(Qt::GlobalColor acolor);
    Qt::BrushStyle style() const;
    const QColor &color() const;
};

QDataStream &operator>>(QDataStream &, QBrush & /Constrained/);
QDataStream &operator<<(QDataStream &, const QBrush & /Constrained/);
typedef QVector<QPair<double, QColor> > QGradientStops;

class QGradient
{

%TypeHeaderCode
#include <qbrush.h>
%End

public:
    enum Type
    {
        LinearGradient,
        RadialGradient,
        ConicalGradient,
        NoGradient,
    };

    enum Spread
    {
        PadSpread,
        ReflectSpread,
        RepeatSpread,
    };

    QGradient();
    QGradient::Type type() const;
    QGradient::Spread spread() const;
    void setColorAt(qreal pos, const QColor &color);
    void setStops(const QGradientStops &stops);
    QGradientStops stops() const;
    bool operator==(const QGradient &gradient) const;
    void setSpread(QGradient::Spread aspread);
};

class QLinearGradient : QGradient
{

%TypeHeaderCode
#include <qbrush.h>
%End

public:
    QLinearGradient(const QPointF &start, const QPointF &finalStop);
    QLinearGradient(qreal xStart, qreal yStart, qreal xFinalStop, qreal yFinalStop);
    QPointF start() const;
    QPointF finalStop() const;
};

class QRadialGradient : QGradient
{

%TypeHeaderCode
#include <qbrush.h>
%End

public:
    QRadialGradient(const QPointF &center, qreal radius, const QPointF &focalPoint = QPointF());
    QRadialGradient(qreal cx, qreal cy, qreal radius, qreal fx = 0, qreal fy = 0);
    QPointF center() const;
    QPointF focalPoint() const;
    qreal radius() const;
};

class QConicalGradient : QGradient
{

%TypeHeaderCode
#include <qbrush.h>
%End

public:
    QConicalGradient(const QPointF &center, qreal startAngle);
    QConicalGradient(qreal cx, qreal cy, qreal startAngle);
    QPointF center() const;
    qreal angle() const;
};
