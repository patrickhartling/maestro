// qbytearray.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qbytearray.h>
%End


char *qstrdup(const char *);
uint qstrlen(const char *str);
char *qstrcpy(char *dst, const char *src);
char *qstrncpy(char *dst, const char *src, uint len);
int qstrcmp(const char *str1, const char *str2);
int qstrncmp(const char *str1, const char *str2, uint len);
int qstricmp(const char *, const char *);
int qstrnicmp(const char *, const char *, uint len);
quint16 qChecksum(const char *s /Array/, uint len /ArraySize/);

class QByteArray
{

%TypeHeaderCode
#include <qbytearray.h>
%End

%TypeCode
// This is needed by __hash__().
#include <qhash.h>
%End

%ConvertToTypeCode
// Allow a Python string whenever a QByteArray is expected.

if (sipIsErr == NULL)
    return (PyString_Check(sipPy) ||
            sipCanConvertToInstance(sipPy, sipClass_QByteArray, SIP_NO_CONVERTORS));

if (PyString_Check(sipPy))
{
    *sipCppPtr = new QByteArray(PyString_AS_STRING(sipPy), PyString_GET_SIZE(sipPy));

    return sipGetState(sipTransferObj);
}

*sipCppPtr = reinterpret_cast<QByteArray *>(sipConvertToInstance(sipPy, sipClass_QByteArray, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%BIGetReadBufferCode
    if (sipSegment != 0)
    {
        PyErr_SetString(PyExc_SystemError, "accessing non-existent QByteArray segment");
        sipRes = -1;
    }
    else
    {
        *sipPtrPtr = (void *)sipCpp->data();
        sipRes = sipCpp->size();
    }
%End

%BIGetSegCountCode
    if (sipLenPtr)
        *sipLenPtr = sipCpp->size();
    
    sipRes = 1;
%End

%BIGetCharBufferCode
    if (sipSegment != 0)
    {
        PyErr_SetString(PyExc_SystemError, "accessing non-existent QByteArray segment");
        sipRes = -1;
    }
    else
    {
        *sipPtrPtr = (void *)sipCpp->data();
        sipRes = sipCpp->size();
    }
%End

public:
    QByteArray();
    QByteArray(int size, char c);
    QByteArray(const QByteArray &a);
    ~QByteArray();
    void resize(int size);
    QByteArray &fill(char c, int size = -1);
    void clear();
    int indexOf(const QByteArray &a, int from = 0) const;
    int indexOf(const QString &s, int from = 0) const;
    int lastIndexOf(const QByteArray &a, int from = -1) const;
    int lastIndexOf(const QString &s, int from = -1) const;
    int count(const QByteArray &a) const;
    QByteArray left(int len) const;
    QByteArray right(int len) const;
    QByteArray mid(int index, int len = -1) const;
    bool startsWith(const QByteArray &a) const;
    bool endsWith(const QByteArray &a) const;
    void truncate(int pos);
    void chop(int n);
    QByteArray toLower() const;
    QByteArray toUpper() const;
    QByteArray trimmed() const;
    QByteArray simplified() const;
    QByteArray leftJustified(int width, char fill = ' ', bool truncate = false) const;
    QByteArray rightJustified(int width, char fill = ' ', bool truncate = false) const;
    QByteArray &prepend(const QByteArray &a);
    QByteArray &append(const QByteArray &a);
    QByteArray &append(const QString &s);
    QByteArray &insert(int i, const QByteArray &a);
    QByteArray &insert(int i, const QString &s);
    QByteArray &remove(int index, int len);
    QByteArray &replace(int index, int len, const QByteArray &s);
    QByteArray &replace(const QByteArray &before, const QByteArray &after);
    QByteArray &replace(const QString &before, const QByteArray &after);
    QList<QByteArray> split(char sep) const;
    QByteArray &operator+=(const QByteArray &a);
    QByteArray &operator+=(const QString &s);
    bool operator==(const QString &s2) const;
    bool operator!=(const QString &s2) const;
    bool operator<(const QString &s2) const;
    bool operator>(const QString &s2) const;
    bool operator<=(const QString &s2) const;
    bool operator>=(const QString &s2) const;
    short toShort(bool *ok = 0, int base = 10) const;
    ushort toUShort(bool *ok = 0, int base = 10) const;
    int toInt(bool *ok = 0, int base = 10) const;
    uint toUInt(bool *ok = 0, int base = 10) const;
    long toLong(bool *ok = 0, int base = 10) const;
    ulong toULong(bool *ok = 0, int base = 10) const;
    qlonglong toLongLong(bool *ok = 0, int base = 10) const;
    qulonglong toULongLong(bool *ok = 0, int base = 10) const;
    float toFloat(bool *ok = 0) const;
    double toDouble(bool *ok = 0) const;
    QByteArray toBase64() const;
    QByteArray &setNum(int n /Constrained/, int base = 10);
    QByteArray &setNum(double /Constrained/, char f = 'g', int prec = 6);
    QByteArray &setNum(qlonglong, int base = 10);
    QByteArray &setNum(qulonglong, int base = 10);
    static QByteArray number(int /Constrained/, int base = 10);
    static QByteArray number(double /Constrained/, char f = 'g', int prec = 6);
    static QByteArray number(qlonglong, int base = 10);
    static QByteArray number(qulonglong, int base = 10);
    static QByteArray fromRawData(const char * /Array/, int size /ArraySize/);
    static QByteArray fromBase64(const QByteArray &base64);
    int count() const;
    int length() const;
    bool isNull() const;
    int size() const;
    const char at(int i) const;
    const char operator[](int i) const;
%MethodCode
        int len;
        
        len = sipCpp->length();
        
        if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
            sipIsErr = 1;
        else
            sipRes = sipCpp->at(a0);
%End

    QByteArray operator[](SIP_PYSLICE slice) const;
%MethodCode
        #if PY_VERSION_HEX >= 0x02050000
        Py_ssize_t len, start, stop, step, slicelength, i;
        #else
        int len, start, stop, step, slicelength, i;
        #endif
        
        len = sipCpp->length();
        
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
            sipIsErr = 1;
        else
        {
            sipRes = new QByteArray();
        
            for (i = 0; i < slicelength; ++i)
            {
                sipRes -> append(sipCpp->at(start));
                start += step;
            }
        }
%End

    int __len__() const;
%MethodCode
        sipRes = sipCpp->length();
%End

    int __contains__(const QByteArray &a) const;
%MethodCode
        // It looks like you can't assign QBool to int.
        sipRes = bool(sipCpp->contains(*a0));
%End

    long __hash__() const;
%MethodCode
        sipRes = qHash(*sipCpp);
%End

    SIP_PYOBJECT __str__();
%MethodCode
        // QByteArrays may have embedded '\0's so set the size explicitly.
        
        char *data = sipCpp->data();
        int len = sipCpp->size();
        
        if (!data)
            sipRes = PyString_FromString("");
        else
            sipRes = PyString_FromStringAndSize(data, len);
%End

    QByteArray operator*(int m) const;
%MethodCode
        sipRes = new QByteArray();
        
        while (a0-- > 0)
            *sipRes += *sipCpp;
%End

    QByteArray &operator*=(int m);
%MethodCode
        QByteArray orig(*sipCpp);
        
        sipCpp->clear();
        
        while (a0-- > 0)
            *sipCpp += orig;
%End

    bool isEmpty() const;
    SIP_PYOBJECT data();
%MethodCode
        // QByteArrays may contain embedded '\0's so set the size explicitly.
        
        char *res = sipCpp->data();
        int len = sipCpp->size();
        
        if (res)
        {
            if ((sipRes = PyString_FromStringAndSize(res, len)) == NULL)
                sipIsErr = 1;
        }
        else
        {
            Py_INCREF(Py_None);
            sipRes = Py_None;
        }
%End

    int capacity() const;
    void reserve(int size);
    void squeeze();
    void push_back(const QByteArray &a);
    void push_front(const QByteArray &a);
    QBool contains(const QByteArray &a) const;
};

bool operator==(const QByteArray &a1, const QByteArray &a2);
bool operator!=(const QByteArray &a1, const QByteArray &a2);
bool operator<(const QByteArray &a1, const QByteArray &a2);
bool operator<=(const QByteArray &a1, const QByteArray &a2);
bool operator>(const QByteArray &a1, const QByteArray &a2);
bool operator>=(const QByteArray &a1, const QByteArray &a2);
const QByteArray operator+(const QByteArray &a1, const QByteArray &a2);
QDataStream &operator<<(QDataStream &, const QByteArray & /Constrained/);
QDataStream &operator>>(QDataStream &, QByteArray & /Constrained/);
QByteArray qCompress(const QByteArray &data, int compressionLevel = -1);
QByteArray qUncompress(const QByteArray &data);
