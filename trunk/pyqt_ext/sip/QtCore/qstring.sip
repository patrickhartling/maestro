// qstring.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qstring.h>
%End


class QString
{

%TypeHeaderCode
#include <qstring.h>
%End

%TypeCode
// Needed by __hash__().
#include <qhash.h>


// Needed by the %BIGetCharBufferCode.
#include <qtextcodec.h>


// Convenience function for converting a QString to a Python Unicode object.
static PyObject *QStringToPyUnicode(QString *qs)
{
    PyObject *uobj;

    if ((uobj = PyUnicode_FromUnicode(NULL, qs->length())) == NULL)
        return NULL;

    Py_UNICODE *pyu = PyUnicode_AS_UNICODE(uobj);

    for (int i = 0; i < qs->length(); ++i)
        *pyu++ = (qs->at(i)).unicode();

    return uobj;
}
%End

%ConvertToTypeCode
// Allow a Python string (or a unicode string) whenever a QString is expected.

if (sipIsErr == NULL)
    return (PyUnicode_Check(sipPy) || PyString_Check(sipPy) ||
            sipCanConvertToInstance(sipPy, sipClass_QString, SIP_NO_CONVERTORS));

if (PyUnicode_Check(sipPy))
{
    QString *qs = new QString;

#if defined(Py_UNICODE_WIDE)
    PY_UNICODE_TYPE *ucode = PyUnicode_AS_UNICODE(sipPy);
    int len = PyUnicode_GET_SIZE(sipPy);

    for (int i = 0; i < len; ++i)
        qs->append((uint)ucode[i]);
#else
        qs->setUtf16((ushort *)PyUnicode_AS_UNICODE(sipPy), PyUnicode_GET_SIZE(sipPy));
#endif

    *sipCppPtr = qs;

    return sipGetState(sipTransferObj);
}

if (PyString_Check(sipPy))
{
    *sipCppPtr = new QString(PyString_AS_STRING(sipPy));

    return sipGetState(sipTransferObj);
}

*sipCppPtr = reinterpret_cast<QString *>(sipConvertToInstance(sipPy, sipClass_QString, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%BIGetReadBufferCode
    if (sipSegment != 0)
    {
        PyErr_SetString(PyExc_SystemError, "accessing non-existent QString segment");
        sipRes = -1;
    }
    else
    {
        *sipPtrPtr = (void *)sipCpp->utf16();
        sipRes = sipCpp->size() * sizeof (ushort);
    }
%End

%BIGetSegCountCode
    if (sipLenPtr)
        *sipLenPtr = sipCpp->size() * sizeof (ushort);
    
    sipRes = 1;
%End

%BIGetCharBufferCode
    if (sipSegment != 0)
    {
        PyErr_SetString(PyExc_SystemError, "accessing non-existent QString segment");
        sipRes = -1;
    }
    else
    {
        static QTextCodec *codec = 0;
        static bool check_codec = TRUE;
    
        // For the first time only, try and find a Qt codec that corresponds to the
        // default Python codec.  If one wasn't found then fall back to ASCII
        // (which is actually the codec returned by QTextCodec::codecForCStrings()).
        if (check_codec)
        {
            codec = QTextCodec::codecForName(PyUnicode_GetDefaultEncoding());
            check_codec = FALSE;
        }
    
        QByteArray enc;
    
        if (codec)
            enc = codec->fromUnicode(*sipCpp);
        else
            enc = sipCpp->toAscii();
    
        // A Python string is the most convenient method to save the encoded
        // version on the heap.
        PyObject *encobj = ((sipWrapper *)sipSelf)->user;
    
        Py_XDECREF(encobj);
    
        if ((encobj = PyString_FromStringAndSize(enc.data(), enc.size())) != NULL)
        {
            *sipPtrPtr = (void *)PyString_AS_STRING(encobj);
            sipRes = PyString_GET_SIZE(encobj);
    
            ((sipWrapper *)sipSelf)->user = encobj;
        }
        else
            sipRes = -1;
    }
%End

public:
    QString();
    QString(QChar c);
    QString(int size, QChar c);
    QString(const QString &s);
    QString(const QLatin1String &latin1);
    QString(const QByteArray &a);
    ~QString();
    int size() const;
    int count() const;
    void resize(int size);
    QString &fill(QChar c, int size = -1);
    void truncate(int pos);
    void chop(int n);
    void squeeze();
    QString arg(int a /Constrained/, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(32)) const;
    QString arg(double a /Constrained/, int fieldWidth = 0, char fmt = 'g', int prec = -1, const QChar &fillChar = QLatin1Char(32)) const;
    QString arg(qlonglong a, int fieldwidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(32)) const;
    QString arg(qulonglong a, int fieldwidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(32)) const;
    QString arg(QChar a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(32)) const;
    QString arg(const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(32)) const;
    QString arg(const QString &a1, const QString &a2) const;
    QString arg(const QString &a1, const QString &a2, const QString &a3) const;
    QString arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4) const;
    int indexOf(QChar c, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(const QString &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(QChar c, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(const QString &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(const QRegExp &, int from = 0) const;
    int lastIndexOf(const QRegExp &, int from = -1) const;
    QBool contains(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    QBool contains(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    QBool contains(const QRegExp &rx) const;
    int count(const QRegExp &) const;

    enum SectionFlag
    {
        SectionDefault,
        SectionSkipEmpty,
        SectionIncludeLeadingSep,
        SectionIncludeTrailingSep,
        SectionCaseInsensitiveSeps,
    };

    typedef QFlags<QString::SectionFlag> SectionFlags;
    QString section(const QString &in_sep, int start, int end = -1, QFlags<QString::SectionFlag> flags = SectionDefault) const;
    QString section(const QRegExp &reg, int start, int end = -1, QFlags<QString::SectionFlag> flags = SectionDefault) const;
    QString left(int len) const;
    QString right(int len) const;
    QString mid(int i, int len = -1) const;
    bool startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    QString leftJustified(int width, QChar fill = QLatin1Char(32), bool trunc = false) const;
    QString rightJustified(int width, QChar fill = QLatin1Char(32), bool trunc = false) const;
    QString toLower() const;
    QString toUpper() const;
    QString trimmed() const;
    QString simplified() const;
    QString &insert(int i, QChar c);
    QString &insert(int i, const QChar *uc, int len);
    QString &insert(int i, const QString &s);
    QString &insert(int i, const QLatin1String &s);
    QString &append(QChar c);
    QString &append(const QString &s);
    QString &append(const QLatin1String &s);
    QString &prepend(QChar c);
    QString &prepend(const QString &s);
    QString &prepend(const QLatin1String &s);
    QString &operator+=(QChar c);
    QString &operator+=(QChar::SpecialCharacter c);
    QString &operator+=(const QString &s);
    QString &operator+=(const QLatin1String &s);
    QString &remove(int i, int len);
    QString &remove(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &remove(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(int i, int len, QChar after);
    QString &replace(int i, int len, const QChar *s, int slen);
    QString &replace(int i, int len, const QString &after);
    QString &replace(QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(QChar c, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(const QRegExp &rx, const QString &after);
    QString &remove(const QRegExp &rx);

    enum SplitBehavior
    {
        KeepEmptyParts,
        SkipEmptyParts,
    };

    QStringList split(const QString &sep, QString::SplitBehavior behavior = QString::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    QStringList split(const QChar &sep, QString::SplitBehavior behavior = QString::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    QStringList split(const QRegExp &sep, QString::SplitBehavior behavior = QString::KeepEmptyParts) const;

    enum NormalizationForm
    {
        NormalizationForm_D,
        NormalizationForm_C,
        NormalizationForm_KD,
        NormalizationForm_KC,
    };

    QString normalized(QString::NormalizationForm mode) const;
    QString normalized(QString::NormalizationForm mode, QChar::UnicodeVersion version) const;
    QByteArray toAscii() const;
    QByteArray toLatin1() const;
    QByteArray toUtf8() const;
    QByteArray toLocal8Bit() const;
    static QString fromAscii(const char *, int size = -1);
    static QString fromLatin1(const char *, int size = -1);
    static QString fromUtf8(const char *, int size = -1);
    static QString fromLocal8Bit(const char *, int size = -1);
    int compare(const QString &s) const;
    static int compare(const QString &s1, const QString &s2);
    int localeAwareCompare(const QString &s) const;
    static int localeAwareCompare(const QString &s1, const QString &s2);
    short toShort(bool *ok = 0, int base = 10) const;
    ushort toUShort(bool *ok = 0, int base = 10) const;
    int toInt(bool *ok = 0, int base = 10) const;
    uint toUInt(bool *ok = 0, int base = 10) const;
    long toLong(bool *ok = 0, int base = 10) const;
    ulong toULong(bool *ok = 0, int base = 10) const;
    qlonglong toLongLong(bool *ok = 0, int base = 10) const;
    qulonglong toULongLong(bool *ok = 0, int base = 10) const;
    float toFloat(bool *ok = 0) const;
    double toDouble(bool *ok = 0) const;
    QString &setNum(int n /Constrained/, int base = 10);
    QString &setNum(double /Constrained/, char f = 'g', int prec = 6);
    QString &setNum(qlonglong, int base = 10);
    QString &setNum(qulonglong, int base = 10);
    static QString number(int /Constrained/, int base = 10);
    static QString number(double /Constrained/, char f = 'g', int prec = 6);
    static QString number(qlonglong, int base = 10);
    static QString number(qulonglong, int base = 10);
    bool operator==(const QString &s) const;
    bool operator<(const QString &s) const;
    bool operator>(const QString &s) const;
    bool operator!=(const QString &s) const;
    bool operator<=(const QString &s) const;
    bool operator>=(const QString &s) const;
    bool operator==(const QLatin1String &s) const;
    bool operator<(const QLatin1String &s) const;
    bool operator>(const QLatin1String &s) const;
    bool operator!=(const QLatin1String &s) const;
    bool operator<=(const QLatin1String &s) const;
    bool operator>=(const QLatin1String &s) const;
    QString &prepend(const QByteArray &s);
    QString &append(const QByteArray &s);
    QString &operator+=(const QByteArray &s);
    bool operator==(const QByteArray &s) const;
    bool operator!=(const QByteArray &s) const;
    bool operator<(const QByteArray &s) const;
    bool operator>(const QByteArray &s) const;
    bool operator<=(const QByteArray &s) const;
    bool operator>=(const QByteArray &s) const;
    void push_back(QChar c);
    void push_back(const QString &s);
    void push_front(QChar c);
    void push_front(const QString &s);
    bool isNull() const;
    bool isSimpleText() const;
    bool isRightToLeft() const;
    int length() const;
    const QChar at(int i) const;
    QString operator[](int i) const;
%MethodCode
        // Note that we return a QString (rather than a QChar as Qt does).  This makes
        // things a bit easier in Python (because it doesn't distinguish between
        // characters and strings).
        int len;
        
        len = sipCpp->length();
        
        if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
            sipIsErr = 1;
        else
            sipRes = new QString(sipCpp->at(a0));
%End

    QString operator[](SIP_PYSLICE slice) const;
%MethodCode
        #if PY_VERSION_HEX >= 0x02050000
        Py_ssize_t len, start, stop, step, slicelength, i;
        #else
        int len, start, stop, step, slicelength, i;
        #endif
        
        len = sipCpp->length();
        
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
            sipIsErr = 1;
        else
        {
            sipRes = new QString();
        
            for (i = 0; i < slicelength; ++i)
            {
                sipRes -> append(sipCpp->at(start));
                start += step;
            }
        }
%End

    int __len__() const;
%MethodCode
        sipRes = sipCpp->length();
%End

    int __contains__(const QString &s) const;
%MethodCode
        // It looks like you can't assign QBool to int.
        sipRes = bool(sipCpp->contains(*a0));
%End

    SIP_PYOBJECT __unicode__();
%MethodCode
        sipRes = QStringToPyUnicode(sipCpp);
%End

    SIP_PYOBJECT __str__();
%MethodCode
        sipRes = QStringToPyUnicode(sipCpp);
%End

    long __hash__() const;
%MethodCode
        sipRes = qHash(*sipCpp);
%End

    QString operator*(int m) const;
%MethodCode
        sipRes = new QString();
        
        while (a0-- > 0)
            *sipRes += *sipCpp;
%End

    QString &operator*=(int m);
%MethodCode
        QString orig(*sipCpp);
        
        sipCpp->clear();
        
        while (a0-- > 0)
            *sipCpp += orig;
%End

    bool isEmpty() const;
    void clear();
    int capacity() const;
    QString section(QChar asep, int astart, int aend = -1, QFlags<QString::SectionFlag> aflags = SectionDefault) const;
    void reserve(int asize);
};

class QLatin1String
{

%TypeHeaderCode
#include <qstring.h>
%End

public:
    explicit QLatin1String(const char *s);
    const char *latin1() const;
    bool operator==(const QString &s) const;
    bool operator!=(const QString &s) const;
    bool operator>(const QString &s) const;
    bool operator<(const QString &s) const;
    bool operator>=(const QString &s) const;
    bool operator<=(const QString &s) const;
};

const QString operator+(const QString &s1, const QString &s2) /Numeric/;
const QString operator+(const QString &s1, QChar s2) /Numeric/;
const QString operator+(QChar s1, const QString &s2) /Numeric/;
const QString operator+(const QByteArray &ba, const QString &s) /Numeric/;
const QString operator+(const QString &s, const QByteArray &ba) /Numeric/;
QDataStream &operator<<(QDataStream &, const QString & /Constrained/);
QDataStream &operator>>(QDataStream &, QString & /Constrained/);
QFlags<QString::SectionFlag> operator|(QString::SectionFlag f1, QFlags<QString::SectionFlag> f2);
QFlags<QString::SectionFlag> operator|(QString::SectionFlag f1, QString::SectionFlag f2);
