// qglobal.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qglobal.h>
%End


// PyQt version information.
int PYQT_VERSION;
char *PYQT_VERSION_STR;

%ModuleCode
static int PYQT_VERSION = 0x040000;
static char *PYQT_VERSION_STR = "4-snapshot-20061008";
%End
const int QT_VERSION;
const char *QT_VERSION_STR;
typedef signed char qint8;
typedef unsigned char quint8;
typedef short qint16;
typedef unsigned short quint16;
typedef int qint32;
typedef unsigned int quint32;
typedef long long qint64;
typedef unsigned long long quint64;
typedef qint64 qlonglong;
typedef quint64 qulonglong;
typedef double qreal;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
double qAbs(const double &t);
int qRound(qreal d);
qint64 qRound64(qreal d);

class QSysInfo
{

%TypeHeaderCode
#include <qglobal.h>
%End

public:
%If (- Qt_4_2_0)

    enum
    {
        WordSize,
    };

%End
%If (Qt_4_2_0 -)

    enum Sizes
    {
        WordSize,
    };

%End

    enum Endian
    {
        BigEndian,
        LittleEndian,
        ByteOrder,
    };

%If (WS_WIN)
// Windows specific system info.
enum WinVersion {
    WV_32s,
    WV_95,
    WV_98,
    WV_Me,
    WV_DOS_based,
    WV_NT,
    WV_2000,
    WV_XP,
    WV_2003,
    WV_NT_based,
    WV_CE,
    WV_CENET,
    WV_CE_based
};

static const WinVersion WindowsVersion;
%End
%If (WS_MACX)
// Mac specific system info.
enum MacVersion {
    MV_Unknown,
    MV_9,
    MV_10_0,
    MV_10_1,
    MV_10_2,
    MV_10_3,
    MV_10_4,
    MV_CHEETAH,
    MV_PUMA,
    MV_JAGUAR,
    MV_PANTHER,
    MV_TIGER,
};

static const MacVersion MacintoshVersion;
%End
};

const char *qVersion();
bool qSharedBuild();
void qDebug(const char *);
void qWarning(const char *);
void qCritical(const char *);
void qFatal(const char *);
void qErrnoWarning(int code, const char *msg);
void qErrnoWarning(const char *msg);

enum QtMsgType
{
    QtDebugMsg,
    QtWarningMsg,
    QtCriticalMsg,
    QtFatalMsg,
    QtSystemMsg,
};

SIP_PYCALLABLE qInstallMsgHandler(SIP_PYCALLABLE /AllowNone/);
%MethodCode
    void (*old)(QtMsgType, const char *);
    
    // Treat None as the default handler.
    old = qInstallMsgHandler((a0 != Py_None) ? qtcore_MsgHandler : 0);
    
    // If we recognise the old handler, then return it.  Otherwise return
    // the default handler.  This doesn't exactly mimic the Qt behaviour
    // but it is probably close enough for the way it will be used.
    sipRes = (old == qtcore_MsgHandler) ? qtcore_PyMsgHandler : Py_None;
    Py_INCREF(sipRes);
    
    // Save the new Python handler.
    Py_XDECREF(qtcore_PyMsgHandler);
    qtcore_PyMsgHandler = a0;
    Py_INCREF(qtcore_PyMsgHandler);
%End

// Module code needed by qInstallMsgHandler().
%ModuleCode
// The user supplied Python handler.
static PyObject *qtcore_PyMsgHandler = 0;

// The C++ wrapper around the Python handler.
static void qtcore_MsgHandler(QtMsgType type, const char *msg)
{
    PyObject *res;

    SIP_BLOCK_THREADS

    res = sipCallMethod(0, qtcore_PyMsgHandler, "Es", type, sipEnum_QtMsgType, msg);
    Py_XDECREF(res);

    if (res != NULL && res != Py_None)
    {
        PyErr_SetString(PyExc_TypeError, "invalid result type from PyQt message handler");
        res = NULL;
    }

    if (res == NULL)
        PyErr_Print();

    SIP_UNBLOCK_THREADS
}
%End
typedef bool QBool;
// Template definition for QFlags.
template<ENUM>
class QFlags
{
public:
    QFlags(const QFlags &f);
    // This is handled by the %ConvertToTypeCode.
    //QFlags(ENUM f);
    QFlags();

    QFlags &operator&=(int mask);
    QFlags &operator|=(QFlags f);
    //QFlags &operator|=(ENUM f);
    QFlags &operator^=(QFlags f);
    //QFlags &operator^=(ENUM f);

    operator int() const;

    QFlags operator|(QFlags f) const;
    //QFlags operator|(ENUM f) const;
    QFlags operator^(QFlags f) const;
    //QFlags operator^(ENUM f) const;
    QFlags operator&(int mask) const;
    //QFlags operator&(ENUM f) const;
    QFlags operator~() const;

    // These are necessary to prevent Python comparing object IDs.
    bool operator==(const QFlags &f) const;
%MethodCode
        sipRes = (sipCpp->operator int() == a0->operator int());
%End

    bool operator!=(const QFlags &f) const;
%MethodCode
        sipRes = (sipCpp->operator int() != a0->operator int());
%End

    int __nonzero__() const;
%MethodCode
        sipRes = (sipCpp-> operator int() != 0);
%End


%ConvertToTypeCode
// Allow an instance of the base enum whenever a QFlags is expected.

if (sipIsErr == NULL)
    return (PyObject_TypeCheck(sipPy, sipEnum_ENUM) ||
            sipCanConvertToInstance(sipPy, sipClass_QFlags, SIP_NO_CONVERTORS));

if (PyObject_TypeCheck(sipPy, sipEnum_ENUM))
{
    *sipCppPtr = new QFlags(PyInt_AsLong(sipPy));

    return sipGetState(sipTransferObj);
}

*sipCppPtr = reinterpret_cast<QFlags *>(sipConvertToInstance(sipPy, sipClass_QFlags, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End
};
// Hook's into Qt's resource system.
%ModuleCode
extern bool qRegisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);
extern bool qUnregisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);
%End

bool qRegisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);
bool qUnregisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);
bool qFuzzyCompare(double p1, double p2);
bool qIsNull(double d);
%If (Qt_4_2_0 -)
void qsrand(uint seed);
%End
%If (Qt_4_2_0 -)
int qrand();
%End
