// qabstractfileengine.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qabstractfileengine.h>
%End


class QAbstractFileEngine
{

%TypeHeaderCode
#include <qabstractfileengine.h>
%End

public:
    enum FileFlag
    {
        ReadOwnerPerm,
        WriteOwnerPerm,
        ExeOwnerPerm,
        ReadUserPerm,
        WriteUserPerm,
        ExeUserPerm,
        ReadGroupPerm,
        WriteGroupPerm,
        ExeGroupPerm,
        ReadOtherPerm,
        WriteOtherPerm,
        ExeOtherPerm,
        LinkType,
        FileType,
        DirectoryType,
        HiddenFlag,
        LocalDiskFlag,
        ExistsFlag,
        RootFlag,
        PermsMask,
        TypesMask,
        FlagsMask,
        FileInfoAll,
    };

    typedef QFlags<QAbstractFileEngine::FileFlag> FileFlags;

    enum FileName
    {
        DefaultName,
        BaseName,
        PathName,
        AbsoluteName,
        AbsolutePathName,
        LinkName,
        CanonicalName,
        CanonicalPathName,
    };

    enum FileOwner
    {
        OwnerUser,
        OwnerGroup,
    };

    enum FileTime
    {
        CreationTime,
        ModificationTime,
        AccessTime,
    };

    virtual ~QAbstractFileEngine();
    virtual bool open(QFlags<QIODevice::OpenModeFlag> openMode) /ReleaseGIL/;
    virtual bool close() /ReleaseGIL/;
    virtual bool flush() /ReleaseGIL/;
    virtual qint64 size() const;
    virtual qint64 pos() const;
    virtual bool seek(qint64 pos) /ReleaseGIL/;
    virtual bool isSequential() const;
    virtual bool remove() /ReleaseGIL/;
    virtual bool copy(const QString &newName) /ReleaseGIL/;
    virtual bool rename(const QString &newName) /ReleaseGIL/;
    virtual bool link(const QString &newName) /ReleaseGIL/;
    virtual bool mkdir(const QString &dirName, bool createParentDirectories) const /ReleaseGIL/;
    virtual bool rmdir(const QString &dirName, bool recurseParentDirectories) const /ReleaseGIL/;
    virtual bool setSize(qint64 size);
    virtual bool caseSensitive() const;
    virtual bool isRelativePath() const;
    virtual QStringList entryList(QFlags<QDir::Filter> filters, const QStringList &filterNames) const;
    virtual QFlags<QAbstractFileEngine::FileFlag> fileFlags(QFlags<QAbstractFileEngine::FileFlag> type = FileInfoAll) const;
    virtual bool setPermissions(uint perms);
    virtual QString fileName(QAbstractFileEngine::FileName file = DefaultName) const;
    virtual uint ownerId(QAbstractFileEngine::FileOwner) const;
    virtual QString owner(QAbstractFileEngine::FileOwner) const;
    virtual QDateTime fileTime(QAbstractFileEngine::FileTime time) const;
    virtual void setFileName(const QString &file);
    virtual int handle() const;
    virtual SIP_PYOBJECT read(qint64 maxlen) /ReleaseGIL/ [qint64 (char *data, qint64 maxlen)];
%MethodCode
        // Return the data read or None if there was an error.
        char *s;
        
        if ((s = (char *)sipMalloc(a0)) == NULL)
            sipIsErr = 1;
        else
        {
            qint64 len;
        
            Py_BEGIN_ALLOW_THREADS
            len = sipSelfWasArg ? sipCpp->QAbstractFileEngine::read(s, a0)
                                : sipCpp->read(s, a0);
            Py_END_ALLOW_THREADS
        
            if (len < 0)
            {
                sipFree((ANY *)s);
        
                Py_INCREF(Py_None);
                sipRes = Py_None;
            }
            else
            {
                sipRes = PyString_FromStringAndSize(s, len);
        
                sipFree((ANY *)s);
        
                if (sipRes == NULL)
                    sipIsErr = 1;
            }
        }
%End

%VirtualCatcherCode
        PyObject *result = sipCallMethod(&sipIsErr, sipMethod, "n", a1);
        
        if (result != NULL)
        {
            PyObject *buf;
        
            sipParseResult(&sipIsErr, sipMethod, result, "O", &buf);
        
            if (buf == Py_None)
                sipRes = -1L;
            else if (!PyString_Check(buf))
            {
                sipBadCatcherResult(sipMethod);
                sipIsErr = 1;
            }
            else
            {
                memcpy(a0, PyString_AS_STRING(buf), PyString_GET_SIZE(buf));
                sipRes = PyString_GET_SIZE(buf);
            }
        
            Py_DECREF(buf);
            Py_DECREF(result);
        }
%End

    virtual SIP_PYOBJECT readLine(qint64 maxlen) /ReleaseGIL/ [qint64 (char *data, qint64 maxlen)];
%MethodCode
        // Return the data read or None if there was an error.
        char *s;
        
        if ((s = (char *)sipMalloc(a0)) == NULL)
            sipIsErr = 1;
        else
        {
            qint64 len;
        
            Py_BEGIN_ALLOW_THREADS
            len = sipSelfWasArg ? sipCpp->QAbstractFileEngine::readLine(s, a0)
                                : sipCpp->readLine(s, a0);
            Py_END_ALLOW_THREADS
        
            if (len < 0)
            {
                sipFree((ANY *)s);
        
                Py_INCREF(Py_None);
                sipRes = Py_None;
            }
            else
            {
                sipRes = PyString_FromStringAndSize(s, len);
        
                sipFree((ANY *)s);
        
                if (sipRes == NULL)
                    sipIsErr = 1;
            }
        }
%End

%VirtualCatcherCode
        PyObject *result = sipCallMethod(&sipIsErr, sipMethod, "n", a1);
        
        if (result != NULL)
        {
            PyObject *buf;
        
            sipParseResult(&sipIsErr, sipMethod, result, "O", &buf);
        
            if (buf == Py_None)
                sipRes = -1L;
            else if (!PyString_Check(buf))
            {
                sipBadCatcherResult(sipMethod);
                sipIsErr = 1;
            }
            else
            {
                memcpy(a0, PyString_AS_STRING(buf), PyString_GET_SIZE(buf));
                sipRes = PyString_GET_SIZE(buf);
            }
        
            Py_DECREF(buf);
            Py_DECREF(result);
        }
%End

    virtual qint64 write(const char *data /Array/, qint64 len /ArraySize/) /ReleaseGIL/;
    QFile::FileError error() const;
    QString errorString() const;
    static QAbstractFileEngine *create(const QString &fileName) /Factory/;

protected:
    void setError(QFile::FileError error, const QString &str);
    QAbstractFileEngine();

private:
%If (Qt_4_2_0 -)
    QAbstractFileEngine(const QAbstractFileEngine &);
%End
};

QFlags<QAbstractFileEngine::FileFlag> operator|(QAbstractFileEngine::FileFlag f1, QFlags<QAbstractFileEngine::FileFlag> f2);
QFlags<QAbstractFileEngine::FileFlag> operator|(QAbstractFileEngine::FileFlag f1, QAbstractFileEngine::FileFlag f2);

class QAbstractFileEngineHandler
{

%TypeHeaderCode
#include <qabstractfileengine.h>
%End

public:
    QAbstractFileEngineHandler();
    virtual ~QAbstractFileEngineHandler();
    virtual QAbstractFileEngine *create(const QString &fileName) const = 0 /Factory/;
};
