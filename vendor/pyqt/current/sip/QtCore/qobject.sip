// qobject.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


class QWidget /External/;
typedef QList<QObject*> QObjectList;

class QObject
{

%TypeHeaderCode
#include <qobject.h>
%End

%TypeCode
// This is needed by the tr() and trUt8() handwritten implementations.
#include <qcoreapplication.h>


// These are the recursive helper functions for QObject::findChild() and
// QObject::findChildren.

static PyObject *qtcore_FindChild(const QObject *parent, PyTypeObject *type, const QString &name)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);

        // Skip if the name doesn't match.
        if (!name.isNull() && obj->objectName() != name)
            continue;

        PyObject *pyo = sipConvertFromInstance(obj, sipClass_QObject, 0);

        if (!pyo || PyType_IsSubtype(pyo->ob_type, type))
            return pyo;

        Py_DECREF(pyo);
    }

    for (i = 0; i < children.size(); ++i)
    {
        PyObject *pyo = qtcore_FindChild(children.at(i), type, name);

        if (pyo != Py_None)
            return pyo;

        Py_DECREF(pyo);
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static int qtcore_FindChildren(const QObject *parent, PyTypeObject *type, const QString &name, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);

        // Skip if the name doesn't match.
        if (!name.isNull() && obj->objectName() != name)
            continue;

        PyObject *pyo = sipConvertFromInstance(obj, sipClass_QObject, 0);

        if (!pyo)
            return -1;

        if (PyType_IsSubtype(pyo->ob_type, type))
            if (PyList_Append(list, pyo) < 0)
            {
                Py_DECREF(pyo);
                return -1;
            }

        Py_DECREF(pyo);

        if (qtcore_FindChildren(obj, type, name, list) < 0)
            return -1;
    }

    return 0;
}

static int qtcore_FindChildren(const QObject *parent, PyTypeObject *type, const QRegExp &re, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);

        // Skip if the name doesn't match.
        if (re.indexIn(obj->objectName()) == -1)
            continue;

        PyObject *pyo = sipConvertFromInstance(obj, sipClass_QObject, 0);

        if (!pyo)
            return -1;

        if (PyType_IsSubtype(pyo->ob_type, type))
            if (PyList_Append(list, pyo) < 0)
            {
                Py_DECREF(pyo);
                return -1;
            }

        Py_DECREF(pyo);

        if (qtcore_FindChildren(obj, type, re, list) < 0)
            return -1;
    }

    return 0;
}
%End

%ConvertToSubClassCode
    static struct class_graph {
        char *name;
        sipWrapperType **type;
        int yes, no;
    } graph[] = {
        {sipName_QAbstractEventDispatcher, &sipClass_QAbstractEventDispatcher, -1, 1},
        {sipName_QEventLoop,               &sipClass_QEventLoop,               -1, 2},
        {sipName_QPluginLoader,            &sipClass_QPluginLoader,            -1, 3},
        {sipName_QSocketNotifier,          &sipClass_QSocketNotifier,          -1, 4},
        {sipName_QLibrary,                 &sipClass_QLibrary,                 -1, 5},
        {sipName_QTranslator,              &sipClass_QTranslator,              -1, 6},
        {sipName_QCoreApplication,         &sipClass_QCoreApplication,         -1, 7},
        {sipName_QSettings,                &sipClass_QSettings,                -1, 8},
        {sipName_QSignalMapper,            &sipClass_QSignalMapper,            -1, 9},
        {sipName_QIODevice,                &sipClass_QIODevice,                15, 10},
        {sipName_QAbstractItemModel,       &sipClass_QAbstractItemModel,       19, 11},
        {sipName_QObjectCleanupHandler,    &sipClass_QObjectCleanupHandler,    -1, 12},
        {sipName_QTimer,                   &sipClass_QTimer,                   -1, 13},
        {sipName_QThread,                  &sipClass_QThread,                  -1, 14},
        {sipName_QMimeData,                &sipClass_QMimeData,                -1, -1},
        {sipName_QFile,                    &sipClass_QFile,                    18, 16},
        {sipName_QProcess,                 &sipClass_QProcess,                 -1, 17},
        {sipName_QBuffer,                  &sipClass_QBuffer,                  -1, -1},
        {sipName_QTemporaryFile,           &sipClass_QTemporaryFile,           -1, -1},
        {sipName_QAbstractTableModel,      &sipClass_QAbstractTableModel,      -1, 20},
        {sipName_QAbstractListModel,       &sipClass_QAbstractListModel,       -1, -1},
    };
    
    int i = 0;
    
    sipClass = NULL;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipClass = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
%End

public:
    explicit QObject(QObject *parent /TransferThis/ = 0);
    virtual ~QObject();
    virtual bool event(QEvent *);
    virtual bool eventFilter(QObject *, QEvent *);
    QString tr(const char *, const char * = 0) const;
%MethodCode
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        PyObject *nmobj = sipClassName(sipSelf);
        
        if (nmobj)
        {
            char *cname = PyString_AsString(nmobj);
        
            if (cname && QCoreApplication::instance())
                sipRes = new QString(QCoreApplication::instance()->translate(cname, a0, a1, QCoreApplication::DefaultCodec));
            else
                sipRes = new QString(QString::fromLatin1(a0));
        
            Py_DECREF(nmobj);
        }
        else
            sipIsErr = 1;
%End

    QString trUtf8(const char *, const char * = 0) const;
%MethodCode
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        PyObject *nmobj = sipClassName(sipSelf);
        
        if (nmobj)
        {
            char *cname = PyString_AsString(nmobj);
        
            if (cname && QCoreApplication::instance())
                sipRes = new QString(QCoreApplication::instance()->translate(cname, a0, a1, QCoreApplication::UnicodeUTF8));
            else
                sipRes = new QString(QString::fromUtf8(a0));
        
            Py_DECREF(nmobj);
        }
        else
            sipIsErr = 1;
%End

    const QMetaObject *metaObject() const;
%MethodCode
        // We do this for historical reasons when SIP didn't distinguish between bound
        // and unbound calls and this allowed us to get the meta-object of unwrapped
        // classes (eg. plugins).  These days we could use the SIP generated code (and
        // not disable it in every QObject sub-class).  We'll leave it for the moment
        // until related issues have been sorted out (eg. Qt Designer custom widgets).
        sipRes = sipCpp->metaObject();
%End

    SIP_PYOBJECT findChild(SIP_PYTYPE type, const QString &name = QString()) const;
%MethodCode
        sipRes = qtcore_FindChild(sipCpp, (PyTypeObject *)a0, *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    SIP_PYLIST findChildren(SIP_PYTYPE type, const QString &name = QString()) const;
%MethodCode
        if ((sipRes = PyList_New(0)) == NULL || qtcore_FindChildren(sipCpp, (PyTypeObject *)a0, *a1, sipRes) < 0)
        {
            Py_XDECREF(sipRes);
            sipIsErr = 1;
        }
%End

    SIP_PYLIST findChildren(SIP_PYTYPE type, const QRegExp &regExp) const;
%MethodCode
        if ((sipRes = PyList_New(0)) == NULL || qtcore_FindChildren(sipCpp, (PyTypeObject *)a0, *a1, sipRes) < 0)
        {
            Py_XDECREF(sipRes);
            sipIsErr = 1;
        }
%End

    void emit(SIP_SIGNAL, ...) const;
%MethodCode
        if (sipEmitSignal(sipSelf, a0, a1) < 0)
            sipIsErr = 1;
%End

    QString objectName() const;
    void setObjectName(const QString &name);
    bool isWidgetType() const;
    bool signalsBlocked() const;
    bool blockSignals(bool b);
    QThread *thread() const;
    void moveToThread(QThread *thread);
    int startTimer(int interval);
    void killTimer(int id);
    const QObjectList &children() const;
    void setParent(QObject * /TransferThis/);
    void installEventFilter(QObject *);
    void removeEventFilter(QObject *);
    static SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_QOBJECT, SIP_SLOT, Qt::ConnectionType=Qt::AutoConnection);
%MethodCode
        sipRes = sipConnectRx(a0, a1, a2, a3, (int)a4);
%End

    static SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_PYCALLABLE, Qt::ConnectionType=Qt::AutoConnection);
%MethodCode
        sipRes = sipConnectRx(a0, a1, a2, 0, (int)a3);
%End

    SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_SLOT, Qt::ConnectionType=Qt::AutoConnection) const;
%MethodCode
        sipRes = sipConnectRx(a0, a1, sipSelf, a2, (int)a3);
%End

    static SIP_PYOBJECT disconnect(SIP_QOBJECT, SIP_SIGNAL, SIP_QOBJECT, SIP_SLOT);
%MethodCode
        sipRes = sipDisconnectRx(a0, a1, a2, a3);
%End

    static SIP_PYOBJECT disconnect(SIP_QOBJECT, SIP_SIGNAL, SIP_PYCALLABLE);
%MethodCode
        sipRes = sipDisconnectRx(a0, a1, a2, 0);
%End

    void dumpObjectTree();
    void dumpObjectInfo();
    bool setProperty(const char *name, const QVariant &value);
    QVariant property(const char *name) const;

signals:
    void destroyed(QObject * = 0);

public:
    QObject *parent() const;
    bool inherits(const char *classname) const;
%MethodCode
        // The Qt implementation doesn't know anything about Python sub-classes so we
        // use the Python type's MRO.
        
        PyObject *mro = sipSelf->ob_type->tp_mro;
        
        sipRes = 0;
        
        for (int i = 0; i < PyTuple_GET_SIZE(mro); ++i)
            if (strcmp(((PyTypeObject *)PyTuple_GET_ITEM(mro, i))->tp_name, a0) == 0)
            {
                sipRes = 1;
                break;
            }
%End

public slots:
    void deleteLater();

protected:
    SIP_PYOBJECT sender() const [QObject * ()];
%MethodCode
        // This is actually protected but we never need to call the real method.
        
        sipRes = sipGetSender();
%End

    int receivers(SIP_SIGNAL signal) const;
%MethodCode
        // We also need to take into account any proxies for Python signals.
        sipRes = sipCpp->sipProtect_receivers(a0);
        
        const QObjectList &children = sipCpp->children();
        
        // Import the helper if it hasn't already been done.
        typedef int (*helper_func)(const QObject *, const char *);
        
        static helper_func helper = 0;
        
        if (!helper)
            helper = (helper_func)sipImportSymbol("qtcore_receivers");
        
        if (helper)
            for (int i = 0; i < children.size(); ++i)
                sipRes += helper(children[i], a0);
%End

    virtual void timerEvent(QTimerEvent *);
    virtual void childEvent(QChildEvent *);
    virtual void customEvent(QEvent *);
    virtual void connectNotify(SIP_SIGNAL signal);
    virtual void disconnectNotify(SIP_SIGNAL signal);

private:
    QObject(const QObject &);
};

SIP_PYOBJECT Q_ENUMS(...);
%MethodCode
    if (sipRegisterIntTypes(a0) < 0)
        sipRes = 0;
    else
    {
        sipRes = Py_None;
        Py_INCREF(sipRes);
    }
%End

SIP_PYOBJECT Q_FLAGS(...);
%MethodCode
    if (sipRegisterIntTypes(a0) < 0)
        sipRes = 0;
    else
    {
        sipRes = Py_None;
        Py_INCREF(sipRes);
    }
%End

SIP_PYOBJECT QT_TR_NOOP(SIP_PYOBJECT);
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TRANSLATE_NOOP(SIP_PYOBJECT, SIP_PYOBJECT);
%MethodCode
    Py_INCREF(a1);
    sipRes = a1;
%End

SIP_PYOBJECT SLOT(const char *);
%MethodCode
    if (!a0)
    {
        PyErr_Format(PyExc_TypeError, "QtCore.SLOT() slot name cannot be None");
        sipIsErr = 1;
    }
    else
    {
        QByteArray ns = QMetaObject::normalizedSignature(a0);
    
        if ((sipRes = PyString_FromStringAndSize(NULL, 1 + ns.size())) == NULL)
            sipIsErr = 1;
        else
        {
            char *dp = PyString_AS_STRING(sipRes);
    
            *dp++ = '1';
    
            qstrcpy(dp, ns.constData());
        }
    }
%End

SIP_PYOBJECT SIGNAL(const char *);
%MethodCode
    if (!a0)
    {
        PyErr_Format(PyExc_TypeError, "QtCore.SIGNAL() signal cannot be None");
        sipIsErr = 1;
    }
    else
    {
        QByteArray ns = QMetaObject::normalizedSignature(a0);
    
        if ((sipRes = PyString_FromStringAndSize(NULL, 1 + ns.size())) == NULL)
            sipIsErr = 1;
        else
        {
            char *dp = PyString_AS_STRING(sipRes);
    
            *dp++ = '2';
    
            qstrcpy(dp, ns.constData());
        }
    }
%End

SIP_PYOBJECT pyqtSignature(const char *);
%MethodCode
    // Normalise the signature and convert it back to a Python string object.
    PyObject *sig = PyString_FromString(QMetaObject::normalizedSignature(a0));
    
    if (sig)
    {
        // Create the decorator function itself.  We stash the signature in "self".
        // This may be an abuse, but it seems to be Ok.
        static PyMethodDef decorator = {
            (char *)"_deco", qtcore_decorator, METH_O, NULL
        };
    
        sipRes = PyCFunction_New(&decorator, sig);
    
        Py_DECREF(sig);
    }
%End

%ModuleCode
// This is the Qt support code for SIP.

#include <qobject.h>
#include <qmetaobject.h>
#include <qmutex.h>


// This class is used as a signal on behalf of Python signals and as a slot on
// behalf of Python callables.  It is derived from QObject but is not run
// through moc.  Instead the normal moc-generated methods are handwritten in
// order to implement a universal signal or slot.  This requires some knowledge
// of the internal implementation of signals and slots but it is likely that
// they will only change between major Qt versions.
class PyQtProxy : public QObject
{
public:
    PyQtProxy(QObject *parent, const char *pysig);
    PyQtProxy(QObject *parent, const sipSignature *psig);
    PyQtProxy(QObject *qtx, sipSlotConnection *conn, const char **member);
    ~PyQtProxy();

    static const QMetaObject staticMetaObject;
    virtual const QMetaObject *metaObject() const;
    virtual void *qt_metacast(const char *);
    virtual int qt_metacall(QMetaObject::Call, int, void **);

    void pysignal(PyObject *pyargs);
    void unislot(void **qargs);

    int getReceivers(const char *signal) const;

    static const QObject *lastSender;

    static QMutex mutex;
    static PyQtProxy *uniproxies;
    PyQtProxy *nextup, *prevup;

    const sipSignature *sig_sig;
    char *pysig_name;
    sipSlotConnection slot_conn;
    bool is_slot;

private:
    void init();

    QMetaObject *sigmo;

    PyQtProxy(const PyQtProxy &);
    PyQtProxy &operator=(const PyQtProxy &);
};


static const uint slot_meta_data[] = {
    // content:
    1,       // revision
    0,       // classname
    0,    0, // classinfo
    2,   10, // methods (number, offset in this array of first one)
    0,    0, // properties
    0,    0, // enums/sets

    // signals: signature, parameters, type, tag, flags
    11,   10,   10,   10, 0x05,

    // slots: signature, parameters, type, tag, flags
    31,   10,   10,   10, 0x0a,

    0        // eod
};


static const char slot_meta_stringdata[] = {
    "PyQtProxy\0\0pysignal(PyObject*)\0unislot()\0"
};


const QMetaObject PyQtProxy::staticMetaObject = {
    {
        &QObject::staticMetaObject,
        slot_meta_stringdata,
        slot_meta_data,
        0
    }
};


// Create a universal proxy used as a shortcut signal.
PyQtProxy::PyQtProxy(QObject *parent, const char *pysig) : QObject(parent), sig_sig(0), is_slot(false), sigmo(0)
{
    // Save the Python signal name.
    pysig_name = new char[qstrlen(pysig) + 1];
    qstrcpy(pysig_name, pysig);

    init();
}


// Create a universal proxy used as a signal.
PyQtProxy::PyQtProxy(QObject *parent, const sipSignature *psig) : QObject(parent), sig_sig(psig), pysig_name(0), is_slot(false)
{
    // Create a new meta-object on the heap so that it looks like it has a
    // signal of the right name and signature.
    sigmo = new QMetaObject;
    sigmo->d.superdata = &QObject::staticMetaObject;
    sigmo->d.extradata = 0;

    // Calculate the size of the string meta-data as follows:
    // - "PyQtProxy" and its terminating '\0',
    // - a '\0' used for any empty string,
    // - the (non-existent) argument names (ie. use the empty string if there
    //   is less that two arguments, otherwise a comma between each argument
    //   and the terminating '\0'),
    // - the name and full signature, less the initial type character, plus the
    //   terminating '\0'.
    size_t nm_len = qstrlen(slot_meta_stringdata) + 1;
    size_t len = nm_len
               + 1
               + (psig->sg_nrargs >= 2 ? psig->sg_nrargs : 0)
               + qstrlen(psig->sg_signature);

    char *smd = new char[len];
    uint i = 0, args_pos, sig_pos;

    qstrcpy(smd, slot_meta_stringdata);
    i += nm_len;

    smd[i++] = '\0';

    if (psig->sg_nrargs >= 2)
    {
        args_pos = i;

        for (int c = 1; c < psig->sg_nrargs; ++c)
            smd[i++] = ',';

        smd[i++] = '\0';
    }
    else
        args_pos = nm_len;

    sig_pos = i;
    qstrcpy(&smd[i], &psig->sg_signature[1]);

    sigmo->d.stringdata = smd;

    // Add the non-string data.
    uint *data = new uint[16];

    for (int d = 0; d < 16; ++d)
        data[d] = staticMetaObject.d.data[d];

    // Fix the changed values;
    data[10] = sig_pos;
    data[11] = args_pos;
    data[14] = 0x05;

    sigmo->d.data = data;

    init();
}


// Create a universal proxy used as a slot.  Note that this will leak if there
// is no signal transmitter (ie. no parent) - QTimer.singleShot() for example.
PyQtProxy::PyQtProxy(QObject *qtx, sipSlotConnection *connection, const char **member) : QObject(), sig_sig(0), pysig_name(0), is_slot(true), sigmo(0)
{
    // Save the connection.
    slot_conn = *connection;

    // Return the slot to connect to.
    *member = SLOT(unislot());

    init();

    // Detect when the transmitter is destroyed.
    if (qtx)
        connect(qtx, SIGNAL(destroyed(QObject *)), SLOT(deleteLater()));
}


// Initialisation common to all ctors.
void PyQtProxy::init()
{
    // Add this one to the global list.
    mutex.lock();

    nextup = uniproxies;

    if (nextup)
        nextup->prevup = this;

    prevup = 0;
    uniproxies = this;

    mutex.unlock();
}


// Destroy a universal proxy.
PyQtProxy::~PyQtProxy()
{
    if (is_slot)
        sipFreeConnection(&slot_conn);

    if (pysig_name)
        delete[] pysig_name;

    if (sigmo)
    {
        // The casts are needed for MSVC 6.
        delete[] const_cast<char *>(sigmo->d.stringdata);
        delete[] const_cast<uint *>(sigmo->d.data);
        delete sigmo;
    }

    // Remove this one from the global list.
    mutex.lock();

    if (nextup)
        nextup->prevup = prevup;

    if (prevup)
        prevup->nextup = nextup;
    else
        uniproxies = nextup;

    mutex.unlock();
}


const QObject *PyQtProxy::lastSender = 0;
QMutex PyQtProxy::mutex(QMutex::Recursive);
PyQtProxy *PyQtProxy::uniproxies = 0;


const QMetaObject *PyQtProxy::metaObject() const
{
    if (sigmo)
        return sigmo;

    return &staticMetaObject;
}


void *PyQtProxy::qt_metacast(const char *_clname)
{
    if (!_clname)
        return 0;

    if (!strcmp(_clname, slot_meta_stringdata))
        return static_cast<void *>(const_cast<PyQtProxy *>(this));

    return QObject::qt_metacast(_clname);
}


int PyQtProxy::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);

    if (_id < 0)
        return _id;

    if (_c == QMetaObject::InvokeMetaMethod)
    {
        switch (_id)
        {
        case 0:
            if (sigmo)
                QMetaObject::activate(this, sigmo, 0, _a);
            else if (sender()->metaObject() == &staticMetaObject)
                pysignal(*reinterpret_cast<PyObject **>(_a[1]));
            break;

        case 1:
            unislot(_a);
            break;
        }

        _id -= 2;
    }

    return _id;
}


// This is the signal that implements Python signals.  The argument is the
// tuple of Python argument objects.
void PyQtProxy::pysignal(PyObject *pyargs)
{
    void *_a[] = {0, reinterpret_cast<void *>(&pyargs)};

    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}


// This is the universal slot itself that dispatches to the real slot.
void PyQtProxy::unislot(void **qargs)
{
    // Save the sender.  If it was a universal signal then the sender we want
    // to save is its parent.
    QObject *sndr = sender();

    if (qstrcmp(sndr->metaObject()->className(), "PyQtProxy") == 0)
        lastSender = sndr->parent();
    else
        lastSender = sndr;

    // See if the sender was a shortcircuited signal. */
    if (sndr->metaObject() == &staticMetaObject)
    {
        // The Python arguments will be the only argument.
        PyObject *pyargs = *reinterpret_cast<PyObject **>(qargs[1]);

        SIP_BLOCK_THREADS

        if (sipEmitToSlot(&slot_conn.sc_slot, pyargs) < 0)
            PyErr_Print();

        SIP_UNBLOCK_THREADS

        return;
    }

    bool ok = TRUE;
    const sipSignature *psig = slot_conn.sc_signature;

    SIP_BLOCK_THREADS

    PyObject *argtup = PyTuple_New(psig->sg_nrargs);

    if (!argtup)
        ok = FALSE;
    else
    {
        for (int a = 0; a < psig->sg_nrargs; ++a)
        {
            PyObject *arg;

            ++qargs;

            switch (psig->sg_args[a].atype)
            {
            case char_sat:
            case schar_sat:
            case uchar_sat:
                arg = PyString_FromStringAndSize((char *)*qargs, 1);
                break;

            case string_sat:
            case sstring_sat:
            case ustring_sat:
                arg = PyString_FromString(*(char **)*qargs);
                break;

            case short_sat:
                arg = PyInt_FromLong(*(short *)*qargs);
                break;

            case ushort_sat:
                arg = PyLong_FromUnsignedLong(*(unsigned short *)*qargs);
                break;

            case int_sat:
                arg = PyInt_FromLong(*(int *)*qargs);
                break;

            case uint_sat:
                arg = PyLong_FromUnsignedLong(*(unsigned *)*qargs);
                break;

            case long_sat:
                arg = PyLong_FromLong(*(long *)*qargs);
                break;

            case ulong_sat:
                arg = PyLong_FromUnsignedLong(*(unsigned long *)*qargs);
                break;

            case longlong_sat:
                arg = PyLong_FromLongLong(*(PY_LONG_LONG *)*qargs);
                break;

            case ulonglong_sat:
                arg = PyLong_FromUnsignedLongLong(*(unsigned PY_LONG_LONG *)*qargs);
                break;

            case float_sat:
                arg = PyFloat_FromDouble(*(float *)*qargs);
                break;

            case double_sat:
                arg = PyFloat_FromDouble(*(double *)*qargs);
                break;

            case enum_sat:
                arg = sipConvertFromNamedEnum(*(int *)*qargs, psig->sg_args[a].u.et);
                break;

            case bool_sat:
                arg = PyBool_FromLong(*(bool *)*qargs);
                break;

            case void_sat:
                arg = sipConvertFromVoidPtr(*(void **)*qargs);
                break;

            case class_sat:
                arg = sipConvertFromInstance(*qargs, psig->sg_args[a].u.wt, 0);
                break;

            case classp_sat:
                arg = sipConvertFromInstance(*(void **)*qargs, psig->sg_args[a].u.wt, 0);
                break;

            case mtype_sat:
                arg = sipConvertFromMappedType(*qargs, psig->sg_args[a].u.mt, 0);
                break;

            case mtypep_sat:
                arg = sipConvertFromMappedType(*(void **)*qargs, psig->sg_args[a].u.mt, 0);
                break;

            case qvariant_sat:
                arg = sipConvertFromInstance(*qargs, sipClass_QVariant, 0);
                break;

            case qvariantp_sat:
                arg = sipConvertFromInstance(*(void **)*qargs, sipClass_QVariant, 0);
                break;

            case pyobject_sat:
                arg = *(PyObject **)*qargs;
                break;

            default:
                arg = Py_NotImplemented;
                Py_INCREF(Py_NotImplemented);
            }

            PyTuple_SET_ITEM(argtup, a, arg);
        }

        // Dispatch to the real slot.
        if (ok && sipEmitToSlot(&slot_conn.sc_slot, argtup) < 0)
            ok = FALSE;

        Py_DECREF(argtup);
    }

    if (!ok)
        PyErr_Print();

    SIP_UNBLOCK_THREADS
}


// A thin wrapper around QObject::receivers().
int PyQtProxy::getReceivers(const char *signal) const
{
    return receivers(signal);
}


// Declare explicit C linkage.
extern "C"
{
    static int sipQtIsQtSignal(void *tx, const char *signal);
    static void *sipQtCreateUniversalSignalShortcut(void *tx,
                    const char *pysig, const char **sig);
    static void *sipQtFindUniversalSignalShortcut(void *tx, const char *pysig,
                    const char **sig);
    static void *sipQtCreateUniversalSignal(void *tx,
                    const sipSignature *psig);
    static void *sipQtFindUniversalSignal(void *tx, const sipSignature *psig);
    static int sipQtEmitSignalShortcut(void *tx, const char *sig,
                    PyObject *sigargs);
    static int sipQtEmitSignal(void *tx, const sipSignature *psig,
                    PyObject *sigargs);
    static void *sipQtCreateUniversalSlot(sipWrapper *tx,
                    sipSlotConnection *conn, const char **member);
    static void sipQtDestroyUniversalSlot(void *rx);
    static void *sipQtFindSlot(void *tx, const char *sig, PyObject *rxObj,
                    const char *slot, const char **member);
    static int sipQtConnect(void *tx, const char *sig, void *rx,
                    const char *slot, int type);
    static int sipQtDisconnect(void *tx, const char *sig, void *rx,
                    const char *slot);
    static int sipQtSignalsBlocked(void *qobj);
    static const void *sipQtGetSender();
    static void sipQtForgetSender();
    static int sipQtSameSignalSlotName(const char *s1, const char *s2);
}


// Return a non-zero value if a signal is a Qt signal.
static int sipQtIsQtSignal(void *tx, const char *signal)
{
    return (reinterpret_cast<QObject *>(tx)->metaObject()->indexOfSignal(&signal[1]) >= 0);
}


// Factory function to create a universal signal instance for a Python
// shortcircuited signal.  Returns a pointer to the instance or 0 if there was
// an error.
static void *sipQtCreateUniversalSignalShortcut(void *tx, const char *pysig, const char **sig)
{
    QObject *qtx = reinterpret_cast<QObject *>(tx);

    *sig = SIGNAL(pysignal(PyObject*));

    // Use an existing one if possible.
    for (PyQtProxy *up = PyQtProxy::uniproxies; up; up = up->nextup)
        if (up->parent() == qtx && up->pysig_name && qstrcmp(up->pysig_name, pysig) == 0)
            return up;

    return new PyQtProxy(qtx, pysig);
}


// Find an existing universal signal instance for a Python shortcircuited
// signal.  Returns a pointer to the instance or 0 there wasn't one.
static void *sipQtFindUniversalSignalShortcut(void *tx, const char *pysig, const char **sig)
{
    QObject *qtx = reinterpret_cast<QObject *>(tx);

    for (PyQtProxy *up = PyQtProxy::uniproxies; up; up = up->nextup)
        if (up->parent() == qtx && up->pysig_name && qstrcmp(up->pysig_name, pysig) == 0)
        {
            *sig = SIGNAL(pysignal(PyObject*));
            return up;
        }

    return 0;
}


// Factory function to create a universal signal instance.  Returns a pointer
// to the instance or 0 if there was an error.
static void *sipQtCreateUniversalSignal(void *tx, const sipSignature *psig)
{
    QObject *qtx = reinterpret_cast<QObject *>(tx);

    // Use an existing one if possible.
    for (PyQtProxy *up = PyQtProxy::uniproxies; up; up = up->nextup)
        if (up->parent() == qtx && up->sig_sig == psig)
            return up;

    return new PyQtProxy(qtx, psig);
}


// Find an existing universal signal instance.  Returns a pointer
// to the instance or 0 if there wasn't one.
static void *sipQtFindUniversalSignal(void *tx, const sipSignature *psig)
{
    QObject *qtx = reinterpret_cast<QObject *>(tx);

    for (PyQtProxy *up = PyQtProxy::uniproxies; up; up = up->nextup)
        if (up->parent() == qtx && up->sig_sig == psig)
            return up;

    return 0;
}


// Emit a shortcut signal for any QObject derived instance.  Returns 0 if there
// was no error.
static int sipQtEmitSignalShortcut(void *tx, const char *sig, PyObject *sigargs)
{
    QObject *qtx = reinterpret_cast<QObject *>(tx);

    // Find the universal signal shortcut.  Unfortunately we can't distinguish
    // between a Qt name with a typo and an unconnected Python signal - so we
    // just ignore the emit.
    PyQtProxy *up;

    for (up = PyQtProxy::uniproxies; up; up = up->nextup)
        if (up->parent() == qtx && up->pysig_name && qstrcmp(up->pysig_name, sig) == 0)
        {
            Py_BEGIN_ALLOW_THREADS
            up->pysignal(sigargs);
            Py_END_ALLOW_THREADS

            break;
        }

    return 0;
}


// Emit a signal for any QObject derived instance.  Returns 0 if there was no
// error.
static int sipQtEmitSignal(void *tx, const sipSignature *psig, PyObject *sigargs)
{
    QObject *qtx;
    const QMetaObject *otxmo;
    int idx;

    qtx = reinterpret_cast<QObject *>(tx);
    otxmo = qtx->metaObject();

    // If the signal doesn't exist then see if there is a proxy for it.
    if ((idx = otxmo->indexOfSignal(&psig->sg_signature[1])) < 0)
    {
        PyQtProxy *up;

        for (up = PyQtProxy::uniproxies; up; up = up->nextup)
            if (up->parent() == qtx && up->sig_sig == psig)
                break;

        // Unfortunately we can't distinguish between a Qt name with a typo and
        // an unconnected Python signal - so we just ignore the emit.
        if (!up)
            return 0;

        // Use the proxy instead.
        qtx = up;
        idx = up->metaObject()->indexOfSignal(&psig->sg_signature[1]);
    }

    // Convert the Python arguments to C++ arguments.  This mimics
    // sipParseArgs().

    void **argv = new void *[1 + psig->sg_nrargs];
    static void *none = 0;

    struct value {
        union {
            bool b;
            short sh;
            unsigned short ush;
            int i;
            unsigned ui;
            long l;
            unsigned long ul;
            PY_LONG_LONG ll;
            unsigned PY_LONG_LONG ull;
            float f;
            double d;
            void *v;
        } u;

        int state;
    };

    value *values = new value[psig->sg_nrargs];

    argv[0] = 0;

    for (int a = 0; a < psig->sg_nrargs; ++a)
    {
        void *arg = 0;
        PyObject *pyarg = PyTuple_GET_ITEM(sigargs, a);
        value *v = &values[a];

        PyErr_Clear();

        switch (psig->sg_args[a].atype)
        {
        case char_sat:
        case schar_sat:
        case uchar_sat:
            if (PyString_Check(pyarg) && PyString_GET_SIZE(pyarg) == 1)
                arg = PyString_AS_STRING(pyarg);
            break;

        case string_sat:
        case sstring_sat:
        case ustring_sat:
            if (pyarg == Py_None)
                arg = &none;
            else if (PyString_Check(pyarg))
                arg = &PyString_AS_STRING(pyarg);
            break;

        case short_sat:
            v->u.sh = PyInt_AsLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.sh;
            break;

        case ushort_sat:
            v->u.ush = sipLong_AsUnsignedLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.ush;
            break;

        case int_sat:
            v->u.i = PyInt_AsLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.i;
            break;

        case uint_sat:
            v->u.ui = sipLong_AsUnsignedLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.ui;
            break;

        case long_sat:
            v->u.l = PyLong_AsLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.l;
            break;

        case ulong_sat:
            v->u.ul = sipLong_AsUnsignedLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.ul;
            break;

        case longlong_sat:
            v->u.ll = PyLong_AsLongLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.ll;
            break;

        case ulonglong_sat:
            v->u.ull = PyLong_AsUnsignedLongLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.ull;
            break;

        case float_sat:
            v->u.f = PyFloat_AsDouble(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.f;
            break;

        case double_sat:
            v->u.d = PyFloat_AsDouble(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.d;
            break;

        case enum_sat:
            if (PyObject_TypeCheck(pyarg, psig->sg_args[a].u.et))
            {
                v->u.i = PyInt_AsLong(pyarg);
                arg = &v->u.i;
            }
            break;

        case bool_sat:
            v->u.b = PyInt_AsLong(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.b;
            break;

        case void_sat:
            v->u.v = sipConvertToVoidPtr(pyarg);

            if (!PyErr_Occurred())
                arg = &v->u.v;
            break;

        case class_sat:
            {
                int iserr = 0;

                arg = sipForceConvertToInstance(pyarg, psig->sg_args[a].u.wt, 0, SIP_NOT_NONE, &values[a].state, &iserr);

                if (iserr)
                    arg = 0;
            }
            break;

        case classp_sat:
            {
                int iserr = 0;

                v->u.v = sipForceConvertToInstance(pyarg, psig->sg_args[a].u.wt, 0, 0, &values[a].state, &iserr);

                if (!iserr)
                    arg = &v->u.v;
            }
            break;

        case mtype_sat:
            {
                int iserr = 0;

                arg = sipForceConvertToMappedType(pyarg, psig->sg_args[a].u.mt, 0, SIP_NOT_NONE, &values[a].state, &iserr);

                if (iserr)
                    arg = 0;
            }
            break;

        case mtypep_sat:
            {
                int iserr = 0;

                v->u.v = sipForceConvertToMappedType(pyarg, psig->sg_args[a].u.mt, 0, 0, &values[a].state, &iserr);

                if (!iserr)
                    arg = &v->u.v;
            }
            break;

        case qvariant_sat:
            {
                int iserr = 0;

                arg = sipForceConvertToInstance(pyarg, sipClass_QVariant, 0, SIP_NOT_NONE, &values[a].state, &iserr);

                if (iserr)
                    arg = 0;
            }
            break;

        case qvariantp_sat:
            {
                int iserr = 0;

                v->u.v = sipForceConvertToInstance(pyarg, sipClass_QVariant, 0, 0, &values[a].state, &iserr);

                if (!iserr)
                    arg = &v->u.v;
            }
            break;

        case pyobject_sat:
            v->u.v = pyarg;
            arg = &v->u.v;
            break;

        default:
            // Do nothing.
            ;
        }

        if (!arg)
        {
            PyErr_Format(PyExc_TypeError, "argument %d of signal %s.%s has an invalid type", a, otxmo->className(), &psig->sg_signature[1]);

            delete[] argv;
            delete[] values;

            return -1;
        }

        argv[1 + a] = arg;
    }

    Py_BEGIN_ALLOW_THREADS
    QMetaObject::activate(qtx, idx, idx, argv);
    Py_END_ALLOW_THREADS

    // Delete any temporary instances.
    for (int a = 0; a < psig->sg_nrargs; ++a)
    {
        value *v = &values[a];

        switch (psig->sg_args[a].atype)
        {
        case class_sat:
            sipReleaseInstance(argv[a], psig->sg_args[a].u.wt, v->state);
            break;

        case classp_sat:
            sipReleaseInstance(v->u.v, psig->sg_args[a].u.wt, v->state);
            break;

        case mtype_sat:
            sipReleaseMappedType(argv[a], psig->sg_args[a].u.mt, v->state);
            break;

        case mtypep_sat:
            sipReleaseMappedType(v->u.v, psig->sg_args[a].u.mt, v->state);
            break;

        case qvariant_sat:
            sipReleaseInstance(argv[a], sipClass_QVariant, v->state);
            break;

        case qvariantp_sat:
            sipReleaseInstance(v->u.v, sipClass_QVariant, v->state);
            break;

        default:
            ;
        }
    }

    delete[] argv;
    delete[] values;

    return 0;
}


// Factory function to create a universal slot instance.  Returns a pointer to
// the instance or 0 if there was an error.
static void *sipQtCreateUniversalSlot(sipWrapper *tx, sipSlotConnection *conn, const char **member)
{
    QObject *qtx = 0;

    // See if the transmitter is a QObject in which case we will connect to
    // it's destroyed signal so that the proxy can be destroyed at the same
    // time.  (Note that we used to do this by making the proxy a child of the
    // transmitter.  This doesn't work as expected because QWidget destroys its
    // children before emitting the destroyed signal.)
    if (tx && PyObject_TypeCheck(tx, (PyTypeObject *)sipClass_QObject))
        qtx = reinterpret_cast<QObject *>(conn->sc_transmitter);

    return new PyQtProxy(qtx, conn, member);
}


// Dispose of a receiver that might be a universal slot.
static void sipQtDestroyUniversalSlot(void *rx)
{
    PyQtProxy::mutex.lock();

    for (PyQtProxy *up = PyQtProxy::uniproxies; up; up = up->nextup)
        if (up == reinterpret_cast<QObject *>(rx) && up->is_slot)
        {
            delete up;
            break;
        }

    PyQtProxy::mutex.unlock();
}


// Search for the universal slot connected to a particular Qt signal.
static void *sipQtFindSlot(void *tx, const char *sig, PyObject *rxObj, const char *slot, const char **member)
{
    // There is no point in locking the mutex as the slot returned could be
    // deleted at any time afterwards anyway.

    for (PyQtProxy *up = PyQtProxy::uniproxies; up; up = up->nextup)
        if (up->is_slot && sipSameConnection(&up->slot_conn, tx, sig, rxObj, slot))
        {
            *member = SLOT(unislot());
            return up;
        }

    return 0;
}


// Connect a Qt signal to a Qt slot.
static int sipQtConnect(void *tx, const char *sig, void *rx, const char *slot, int type)
{
    // Unlike Qt3, Qt4 does not check that the signal and slot arguments are
    // compatible in a release build.  I think this is a bug, so we do the
    // missing check here.
#if defined(QT_NO_DEBUG)
    if (!QMetaObject::checkConnectArgs(sig, slot))
        return 0;
#endif

    return QObject::connect(reinterpret_cast<QObject *>(tx), sig,
                            reinterpret_cast<QObject *>(rx), slot,
                            (Qt::ConnectionType)type);
}


// Disconnect a Qt signal from a Qt slot.
static int sipQtDisconnect(void *tx, const char *sig, void *rx, const char *slot)
{
    return QObject::disconnect(reinterpret_cast<QObject *>(tx), sig,
                               reinterpret_cast<QObject *>(rx), slot);
}


// See if signals are currently blocked for a QObject.
static int sipQtSignalsBlocked(void *qobj)
{
    return reinterpret_cast<QObject *>(qobj)->signalsBlocked();
}


// Get the last sender for QObject::sender().
static const void *sipQtGetSender()
{
    return PyQtProxy::lastSender;
}


// Forget the last sender.
static void sipQtForgetSender()
{
    PyQtProxy::lastSender = 0;
}


// See if two signal or slot names are the same.
static int sipQtSameSignalSlotName(const char *s1, const char *s2)
{
    // Signal and slot names are always normalised so a simple string
    // comparison will do.
    return (qstrcmp(s1, s2) == 0);
}


// This is a helper for QObject.receivers() that returns the number of
// receivers for an object if it is a signal proxy.  It is exported because
// QObject::receivers() is protected.
static int qtcore_receivers(const QObject *obj, const char *signal)
{
    if (qstrcmp(obj->metaObject()->className(), "PyQtProxy") != 0)
            return 0;

    return static_cast<const PyQtProxy *>(obj)->getReceivers(signal);
}


// This is the decorator function that saves the C++ signature as a function
// attribute.
extern "C" {static PyObject *qtcore_decorator(PyObject *self, PyObject *f);}

static PyObject *qtcore_decorator(PyObject *self, PyObject *f)
{
    static PyObject *sigstr = 0;

    // Objectify the attribute name.
    if (!sigstr)
    {
        sigstr = PyString_FromString("_signature");

        if (!sigstr)
            return 0;
    }

    // Save the signature as an attribute.
    if (PyObject_SetAttr(f, sigstr, self) < 0)
        return 0;

    // Return the function.
    Py_INCREF(f);
    return f;
}
%End

%PostInitialisationCode
// Export the QObject.receivers() helper.
sipExportSymbol("qtcore_receivers", (void *)qtcore_receivers);
%End
