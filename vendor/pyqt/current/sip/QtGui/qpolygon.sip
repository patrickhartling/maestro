// qpolygon.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qpolygon.h>
%End


class QPolygon
{

%TypeHeaderCode
#include <qpolygon.h>
%End

%TypeCode
// Set the points of a polygon from a Python list.
static bool setPointsFromList(QPolygon *poly, PyObject *l)
{
    int *coords = new int[PyList_GET_SIZE(l)];

    for (int i = 0; i < PyList_GET_SIZE(l); ++i)
    {
        coords[i] = PyInt_AsLong(PyList_GET_ITEM(l, i));

        if (PyErr_Occurred() != NULL)
        {
            delete[] coords;
            return false;
        }
    }

    poly->setPoints(PyList_GET_SIZE(l) >> 1, coords);

    delete[] coords;
    return true;
}
%End

public:
    QPolygon();
    ~QPolygon();
    QPolygon(const QPolygon &a);
    QPolygon(const QVector<QPoint> &v);
    QPolygon(const QRect &r, bool closed = false);
    QPolygon(int asize);
    QPolygon(SIP_PYLIST) /NoDerived/;
%MethodCode
        sipCpp = new QPolygon();
        
        if (!setPointsFromList(sipCpp, a0))
        {
            delete sipCpp;
            sipCpp = 0;
            sipIsErr = 1;
        }
%End

    QPolygon(const QVariant &) /NoDerived/;
%MethodCode
        sipCpp = new QPolygon(qVariantValue<QPolygon>(*a0));
%End

    operator QVariant() const;
    void translate(int dx, int dy);
    QRect boundingRect() const;
    QPoint point(int index) const;
    void setPoints(SIP_PYLIST);
%MethodCode
        if (!setPointsFromList(sipCpp, a0))
            sipIsErr = 1;
%End

    void setPoints(int firstx, int firsty, ...);
%MethodCode
        // Accept at least one pair of integer coordinates.
        int nPoints = 1 + ((PyTuple_GET_SIZE(a2) + 1) >> 1);
        
        int *points = new int[nPoints * 2];
        
        points[0] = a0;
        points[1] = a1;
        
        for (int i = 0; i < PyTuple_GET_SIZE(a2); ++i)
            points[2 + i] = PyInt_AsLong(PyTuple_GET_ITEM(a2, i));
        
        sipCpp->setPoints(nPoints, points);
        
        delete[] points;
%End

    void putPoints(int index, int firstx, int firsty, ...);
%MethodCode
        // Accept at least one pair of integer coordinates.
        int nPoints = 1 + ((PyTuple_GET_SIZE(a3) + 1) >> 1);
        
        int *points = new int[nPoints * 2];
        
        points[0] = a1;
        points[1] = a2;
        
        for (int i = 0; i < PyTuple_GET_SIZE(a3); ++i)
            points[2 + i] = PyInt_AsLong(PyTuple_GET_ITEM(a3, i));
        
        sipCpp->putPoints(a0, nPoints, points);
        
        delete[] points;
%End

    void putPoints(int index, int nPoints, const QPolygon &from, int fromIndex = 0);
    void setPoint(int index, const QPoint &pt);
    void setPoint(int index, int x, int y);
    void translate(const QPoint &offset);
// Methods inherited from QVector<QPoint> and Python special methods.
// Keep in sync with QPolygonF.
void append(const QPoint &value);
const QPoint &at(int i) const;
void clear();
bool contains(const QPoint &value) const;
int count(const QPoint &value) const;
int count() const;

// Note the Qt return value is discarded as it would require handwritten code
// and seems pretty useless.
void fill(const QPoint &value, int size = -1);

QPoint &first();
int indexOf(const QPoint &value, int from = 0) const;
void insert(int i, const QPoint &value);
bool isEmpty() const;
QPoint &last();
int lastIndexOf(const QPoint &value, int from = -1) const;

// Note the Qt return type is QVector<QPoint>.
QPolygon mid(int pos, int length = -1) const;

void prepend(const QPoint &value);
void remove(int i);
void remove(int i, int count);
void replace(int i, const QPoint &value);
int size() const;
QPoint value(int i) const;
QPoint value(int i, const QPoint &defaultValue) const;
bool operator!=(const QPolygon &other) const;

// Note the Qt return type is QVector<QPoint>.
QPolygon operator+(const QPolygon &other) const;

QPolygon &operator+=(const QPolygon &other);
QPolygon &operator+=(const QPoint &value);
bool operator==(const QPolygon &other) const;
QPoint &operator[](int i);

// Some additional Python special methods.

int __len__();
%MethodCode
    sipRes = sipCpp->count();
%End

void __setitem__(int i, const QPoint &value);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    (*sipCpp)[a0] = *a1;
%End

void __setitem__(SIP_PYSLICE slice, const QPolygon &list);
%MethodCode
#if PY_VERSION_HEX >= 0x02050000
Py_ssize_t len, start, stop, step, slicelength, i;
#else
int len, start, stop, step, slicelength, i;
#endif

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
{
    int vlen = a1->count();

    if (vlen != slicelength)
    {
        sipBadLengthForSlice(vlen, slicelength);
        sipIsErr = 1;
    }
    else
    {
        QVector<QPoint>::const_iterator it = a1->begin();

        for (i = 0; i < slicelength; ++i)
        {
            (*sipCpp)[start] = *it;
            start += step;
            ++it;
        }
    }
}
%End

void __delitem__(int i);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    sipCpp->remove(a0);
%End

void __delitem__(SIP_PYSLICE slice, const QPolygon &list);
%MethodCode
#if PY_VERSION_HEX >= 0x02050000
Py_ssize_t len, start, stop, step, slicelength, i;
#else
int len, start, stop, step, slicelength, i;
#endif

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
    for (i = 0; i < slicelength; ++i)
    {
        sipCpp->remove(start);
        start += step - 1;
    }
%End

QPolygon &operator[](SIP_PYSLICE slice);
%MethodCode
#if PY_VERSION_HEX >= 0x02050000
Py_ssize_t len, start, stop, step, slicelength, i;
#else
int len, start, stop, step, slicelength, i;
#endif

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
{
    sipRes = new QPolygon();

    for (i = 0; i < slicelength; ++i)
    {
        (*sipRes) += (*sipCpp)[start];
        start += step;
    }
}
%End

int __contains__(const QPoint &value);
%MethodCode
// It looks like you can't assign QBool to int.
sipRes = bool(sipCpp->contains(*a0));
%End
};

class QPolygonF
{

%TypeHeaderCode
#include <qpolygon.h>
%End

public:
    QPolygonF();
    ~QPolygonF();
    QPolygonF(const QPolygonF &a);
    QPolygonF(const QVector<QPointF> &v);
    QPolygonF(const QRectF &r);
    QPolygonF(const QPolygon &a);
    QPolygonF(int asize);
    void translate(const QPointF &offset);
    QPolygon toPolygon() const;
    bool isClosed() const;
    QRectF boundingRect() const;
    void translate(qreal dx, qreal dy);
// Methods inherited from QVector<QPointF> and Python special methods.
// Keep in sync with QPolygon.
void append(const QPointF &value);
const QPointF &at(int i) const;
void clear();
bool contains(const QPointF &value) const;
int count(const QPointF &value) const;
int count() const;

// Note the Qt return value is discarded as it would require handwritten code
// and seems pretty useless.
void fill(const QPointF &value, int size = -1);

QPointF &first();
int indexOf(const QPointF &value, int from = 0) const;
void insert(int i, const QPointF &value);
bool isEmpty() const;
QPointF &last();
int lastIndexOf(const QPointF &value, int from = -1) const;

// Note the Qt return type is QVector<QPointF>.
QPolygonF mid(int pos, int length = -1) const;

void prepend(const QPointF &value);
void remove(int i);
void remove(int i, int count);
void replace(int i, const QPointF &value);
int size() const;
QPointF value(int i) const;
QPointF value(int i, const QPointF &defaultValue) const;
bool operator!=(const QPolygonF &other) const;

// Note the Qt return type is QVector<QPointF>.
QPolygonF operator+(const QPolygonF &other) const;

QPolygonF &operator+=(const QPolygonF &other);
QPolygonF &operator+=(const QPointF &value);
bool operator==(const QPolygonF &other) const;
QPointF &operator[](int i);

// Some additional Python special methods.

int __len__();
%MethodCode
    sipRes = sipCpp->count();
%End

void __setitem__(int i, const QPointF &value);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    (*sipCpp)[a0] = *a1;
%End

void __setitem__(SIP_PYSLICE slice, const QPolygonF &list);
%MethodCode
#if PY_VERSION_HEX >= 0x02050000
Py_ssize_t len, start, stop, step, slicelength, i;
#else
int len, start, stop, step, slicelength, i;
#endif

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
{
    int vlen = a1->count();

    if (vlen != slicelength)
    {
        sipBadLengthForSlice(vlen, slicelength);
        sipIsErr = 1;
    }
    else
    {
        QVector<QPointF>::const_iterator it = a1->begin();

        for (i = 0; i < slicelength; ++i)
        {
            (*sipCpp)[start] = *it;
            start += step;
            ++it;
        }
    }
}
%End

void __delitem__(int i);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    sipCpp->remove(a0);
%End

void __delitem__(SIP_PYSLICE slice, const QPolygonF &list);
%MethodCode
#if PY_VERSION_HEX >= 0x02050000
Py_ssize_t len, start, stop, step, slicelength, i;
#else
int len, start, stop, step, slicelength, i;
#endif

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
    for (i = 0; i < slicelength; ++i)
    {
        sipCpp->remove(start);
        start += step - 1;
    }
%End

QPolygonF &operator[](SIP_PYSLICE slice);
%MethodCode
#if PY_VERSION_HEX >= 0x02050000
Py_ssize_t len, start, stop, step, slicelength, i;
#else
int len, start, stop, step, slicelength, i;
#endif

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
{
    sipRes = new QPolygonF();

    for (i = 0; i < slicelength; ++i)
    {
        (*sipRes) += (*sipCpp)[start];
        start += step;
    }
}
%End

int __contains__(const QPointF &value);
%MethodCode
// It looks like you can't assign QBool to int.
sipRes = bool(sipCpp->contains(*a0));
%End
};

QDataStream &operator<<(QDataStream &stream, const QPolygonF &array /Constrained/);
QDataStream &operator>>(QDataStream &stream, QPolygonF &array /Constrained/);
