// qimage.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qimage.h>
%End


class QImage : QPaintDevice
{

%TypeHeaderCode
#include <qimage.h>
%End

public:
    enum InvertMode
    {
        InvertRgb,
        InvertRgba,
    };

    enum Format
    {
        Format_Invalid,
        Format_Mono,
        Format_MonoLSB,
        Format_Indexed8,
        Format_RGB32,
        Format_ARGB32,
        Format_ARGB32_Premultiplied,
%If (Qt_4_1_3 -)
        NImageFormats,
%End
    };

    QImage();
    QImage(const QSize &size, QImage::Format format);
    QImage(int width, int height, QImage::Format format);
    QImage(uchar *data, int width, int height, QImage::Format format);
    explicit QImage(SIP_PYLIST xpm) [(const char **xpm)];
%MethodCode
        // The Python interface is a list of strings that make up the image.
        
        const char **str;
        
        if ((str = QtGui_ListToArray(a0)) == NULL)
            sipIsErr = 1;
        else
        {
            sipCpp = new sipQImage(str);
        
            sipFree((ANY *)str);
        }
%End

    QImage(const QString &fileName, const char *format = 0);
    QImage(const QVariant &) /NoDerived/;
%MethodCode
        sipCpp = new sipQImage(qVariantValue<QImage>(*a0));
%End

    QImage(const QImage &);
    virtual ~QImage();
    bool isNull() const;
    virtual int devType() const;
    bool operator==(const QImage &) const;
    bool operator!=(const QImage &) const;
    operator QVariant() const;
    void detach();
    bool isDetached() const;
    QImage copy(const QRect &rect = QRect()) const;
    QImage copy(int x, int y, int w, int h) const;
    QImage::Format format() const;
    QImage convertToFormat(QImage::Format f, Qt::ImageConversionFlags flags = Qt::AutoColor) const;
    QImage convertToFormat(QImage::Format f, const QVector<unsigned int> &colorTable, Qt::ImageConversionFlags flags = Qt::AutoColor) const;
    int width() const;
    int height() const;
    QSize size() const;
    QRect rect() const;
    int depth() const;
    int numColors() const;
    QRgb color(int i) const;
    void setColor(int i, QRgb c);
    void setNumColors(int);
    bool allGray() const;
    bool isGrayscale() const;
    void *bits();
    int numBytes() const;
    void *scanLine(int);
    int bytesPerLine() const;
    bool valid(int x, int y) const;
    int pixelIndex(int x, int y) const;
    QRgb pixel(int x, int y) const;
    void setPixel(int x, int y, uint index_or_rgb);
    QVector<unsigned int> colorTable() const;
    void setColorTable(const QVector<unsigned int> colors);
    void fill(uint pixel);
    bool hasAlphaChannel() const;
    void setAlphaChannel(const QImage &alphaChannel);
    QImage alphaChannel() const;
    QImage createAlphaMask(Qt::ImageConversionFlags flags = Qt::AutoColor) const;
    QImage createHeuristicMask(bool clipTight = true) const;
    QImage scaled(int w, int h, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage scaled(const QSize &s, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage scaledToWidth(int w, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage scaledToHeight(int h, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage transformed(const QMatrix &matrix, Qt::TransformationMode mode = Qt::FastTransformation) const;
    static QMatrix trueMatrix(const QMatrix &, int w, int h);
    QImage mirrored(bool horizontally = false, bool vertically = true) const;
    QImage rgbSwapped() const;
    void invertPixels(QImage::InvertMode = QImage::InvertRgb);
    bool load(QIODevice *device, const char *format);
    bool load(const QString &fileName, const char *format = 0);
    bool loadFromData(const uchar *buf /Array/, int len /ArraySize/, const char *format = 0);
    bool loadFromData(const QByteArray &data, const char *aformat = 0);
    bool save(const QString &fileName, const char *format, int quality = -1) const;
    bool save(QIODevice *device, const char *format, int quality = -1) const;
    static QImage fromData(const uchar *data /Array/, int size /ArraySize/, const char *format = 0);
    static QImage fromData(const QByteArray &data, const char *format = 0);
    int serialNumber() const;
    virtual QPaintEngine *paintEngine() const;
    int dotsPerMeterX() const;
    int dotsPerMeterY() const;
    void setDotsPerMeterX(int);
    void setDotsPerMeterY(int);
    QPoint offset() const;
    void setOffset(const QPoint &);
    QStringList textKeys() const;
    QString text(const QString &key = QString()) const;
    void setText(const QString &key, const QString &value);

protected:
    virtual int metric(QPaintDevice::PaintDeviceMetric metric) const;
};

QDataStream &operator<<(QDataStream &, const QImage & /Constrained/);
QDataStream &operator>>(QDataStream &, QImage & /Constrained/);

%ModuleHeaderCode
const char **QtGui_ListToArray(PyObject *lst);
%End

%ModuleCode
// Convert a list of strings to an array of strings on the heap.  Used by
// QImage and QPixmap.
const char **QtGui_ListToArray(PyObject *lst)
{
    int nstr;
    const char **str, **sp;

    nstr = PyList_Size(lst);

    if ((str = (const char **)sipMalloc(nstr * sizeof (char *))) == NULL)
        return NULL;

    // Convert the list.
    sp = str;

    for (int i = 0; i < nstr; ++i)
    {
        char *s;

        if ((s = PyString_AsString(PyList_GetItem(lst, i))) == NULL)
        {
            sipFree((ANY *)str);
            return NULL;
        }

        *sp++ = s;
    }

    return str;
}
%End
