// qpicture.sip generated by MetaSIP on Wed Oct 11 03:37:27 2006
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2006
// 	Riverbank Computing Limited <info@riverbankcomputing.co.uk>
// 
// This file is part of PyQt.
// 
// This copy of PyQt is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2, or (at your option) any later
// version.
// 
// PyQt is supplied in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along with
// PyQt; see the file LICENSE.  If not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


%ModuleHeaderCode
#include <qpicture.h>
%End


class QPicture : QPaintDevice
{

%TypeHeaderCode
#include <qpicture.h>
%End

public:
    explicit QPicture(int formatVersion = -1);
    QPicture(const QPicture &);
    virtual ~QPicture();
    bool isNull() const;
    virtual int devType() const;
    uint size() const;
    const char *data() const;
    virtual void setData(const char *data /Array/, uint size /ArraySize/);
    bool play(QPainter *p);
    bool load(QIODevice *dev, const char *format = 0) /ReleaseGIL/;
    bool load(const QString &fileName, const char *format = 0) /ReleaseGIL/;
    bool save(QIODevice *dev, const char *format = 0) /ReleaseGIL/;
    bool save(const QString &fileName, const char *format = 0) /ReleaseGIL/;
    QRect boundingRect() const;
    void setBoundingRect(const QRect &r);
    void detach();
    bool isDetached() const;
    static const char *pictureFormat(const QString &fileName);
    static QList<QByteArray> inputFormats();
    static QList<QByteArray> outputFormats();
    static QStringList inputFormatList();
    static QStringList outputFormatList();
    virtual QPaintEngine *paintEngine() const;

protected:
    virtual int metric(QPaintDevice::PaintDeviceMetric m) const;
};

class QPictureIO
{

%TypeHeaderCode
#include <qpicture.h>
%End

%TypeCode
// This defines the mapping between picture formats and the corresponding
// Python i/o handler callables.
struct qtgui_pio {
    const char *format;     // The format.
    PyObject *read;         // The read handler.
    PyObject *write;        // The write handler.
    qtgui_pio *next;        // The next in the list.
};


// The head of the list.
static qtgui_pio *qtgui_pio_head = 0;


// Find the entry for the given picture.
static const qtgui_pio *qtgui_pio_find(QPictureIO *pio)
{
    for (const qtgui_pio *p = qtgui_pio_head; p; p = p->next)
        if (qstrcmp(pio->format(), p->format) == 0)
            return p;

    return 0;
}


// This is the C++ read handler.
static void qtgui_pio_read(QPictureIO *pio)
{
    const qtgui_pio *p = qtgui_pio_find(pio);

    if (p && p->read)
        Py_XDECREF(sipCallMethod(0, p->read, "M", pio, sipClass_QPictureIO));
}


// This is the C++ write handler.
static void qtgui_pio_write(QPictureIO *pio)
{
    const qtgui_pio *p = qtgui_pio_find(pio);

    if (p && p->write)
        Py_XDECREF(sipCallMethod(0, p->write, "M", pio, sipClass_QPictureIO));
}
%End

public:
    QPictureIO();
    QPictureIO(QIODevice *ioDevice, const char *format);
    QPictureIO(const QString &fileName, const char *format);
    ~QPictureIO();
    const QPicture &picture() const;
    int status() const;
    const char *format() const;
    QIODevice *ioDevice() const;
    QString fileName() const;
    int quality() const;
    QString description() const;
    const char *parameters() const;
    float gamma() const;
    void setPicture(const QPicture &);
    void setStatus(int);
    void setFormat(const char *);
    void setIODevice(QIODevice *);
    void setFileName(const QString &);
    void setQuality(int);
    void setDescription(const QString &);
    void setParameters(const char *);
    void setGamma(float);
    bool read() /ReleaseGIL/;
    bool write() /ReleaseGIL/;
    static QByteArray pictureFormat(const QString &fileName);
    static QByteArray pictureFormat(QIODevice *);
    static QList<QByteArray> inputFormats();
    static QList<QByteArray> outputFormats();
    static void defineIOHandler(const char *format, const char *header, const char *flags, SIP_PYCALLABLE read_picture /AllowNone/, SIP_PYCALLABLE write_picture /AllowNone/);
%MethodCode
        // Convert None to NULL.
        if (a3 == Py_None)
            a3 = 0;
        
        if (a4 == Py_None)
            a4 = 0;
        
        // See if we already know about the format.
        qtgui_pio *p;
        
        for (p = qtgui_pio_head; p; p = p->next)
            if (qstrcmp(a0, p->format) == 0)
                break;
        
        if (!p)
        {
            // Handle the new format.
            p = new qtgui_pio;
            p->format = qstrdup(a0);
            p->read = 0;
            p->write = 0;
            p->next = qtgui_pio_head;
        
            qtgui_pio_head = p;
        }
        
        // Replace the old callables with the new ones.
        Py_XDECREF(p->read);
        p->read = a3;
        Py_XINCREF(p->read);
        
        Py_XDECREF(p->write);
        p->write = a4;
        Py_XINCREF(p->write);
        
        // Install the generic handlers.
        QPictureIO::defineIOHandler(a0, a1, a2, qtgui_pio_read, qtgui_pio_write);
%End

private:
    QPictureIO(const QPictureIO &);
};

QDataStream &operator<<(QDataStream &in, const QPicture &p /Constrained/);
QDataStream &operator>>(QDataStream &in, QPicture &p /Constrained/);
